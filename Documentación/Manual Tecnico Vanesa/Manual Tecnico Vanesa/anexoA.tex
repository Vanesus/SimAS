%==================================================================================
%   Anexo 1: Fundamentos teóricos de las gramáticas de contexto libre
%==================================================================================


\chapter {Gramáticas formales}


\section{Definición de gramática formal}\label{sec-gramatica-formal}

\begin{definicion}
 Una {\bf\em gramática formal} $G$ se define como
\begin{equation}
    G = (V_N, V_T,P,S)
\end{equation}
donde
\begin{itemize}
\item $V_N$ es un conjunto finito de símbolos que se denomina {\bf\em alfabeto no terminal} y también puede ser denotado por $\Sigma_N$ o $N$.
\item $V_T$ es un conjunto finito de símbolos que se denomina {\bf\em alfabeto terminal} y también puede ser denotado por $\Sigma_T$ o $T$,
\item $S \in V_N$ y es el {\bf\em axioma} o {\bf\em símbolo inicial o distinguido} de la gramática  y
\item $P$ es el {\bf\em conjunto de reglas de reescritura o de  producción}. 
\end{itemize}
\end{definicion}

 Se verifica que 
\begin{eqnarray}
    V_N \cup V_T = V \\
    V_N \cap V_T = \emptyset
\end{eqnarray}

 $V$ es el {\bf\em alfabeto o vocabulario} de la gramática y también suele ser denotado por $\Sigma$.

 El conjunto de producciones $P$ se define como 
\begin{equation}
  P = \{ (\alpha, \beta) | \alpha = \delta A \gamma, A \in V_N, \delta, \alpha, \gamma \in V^* = (V_N \cup V_T)^* \}
\end{equation}

 El par $(\alpha, \beta)$ suele ser denotado por 
\begin{equation}
  \alpha \rightarrow \beta
\end{equation}
siendo $\alpha$ la parte izquierda de la regla de producción y $\beta$ la parte derecha.

 Puesto que $\alpha = \delta A \gamma$, se requiere que $\alpha$ contenga al menos un símbolo no terminal. 


 Una gramática ``formal'' establece las reglas que permiten generar palabras de un lenguaje.

\begin{ejemplo} Ejemplo de gramática formal.

 $$G = (\{S,A,B\}, \{a,b,c\}, P, S)$$
donde 
\begin{eqnarray*}
  P & = & \{ \\
    &   & S \longrightarrow A a \\
    &   & S \longrightarrow a b B \\ 
    &   & A \longrightarrow A c B \\ 
    &   & A c \longrightarrow b B \\ 
    &   & c B \longrightarrow B c c  \\ 
    &   & B \longrightarrow B a \\ 
    &   & B \longrightarrow b c \\ 
    &   & \}
\end{eqnarray*}
\end{ejemplo}

\subsection{Convenios de notación}

 Se suelen utilizar los siguientes convenios de notación para definir las gramáticas formales:
\begin{enumerate}
\item Símbolos terminales, es decir,  pertenecientes a $V_T$: 
	\begin{itemize}
	\item Primeras letras minúsculas del alfabeto latino: \{{\em a, b, c, $\dots$}\}
	\item Operadores ariméticos, lógicos, relacionales: \{{\em +, -, *, /, $\vee$, $\wedge$, $<$, $>$, $\leq$, $\dots$}\}
	\item Cifras numéricas: \{{\em 0, 1, $\dots$, 9}\}
	\item Símbolos especiales: \{{\em [, ], (, ), ;, $\dots$}\}
	\item Palabras en negrita: \{{\bf\em if, else, entonces, para, $\dots$}\}
	\end{itemize}
\item Símbolos no terminales\footnote{Los símbolos no terminales también se denominan ``variables'' de la gramática.}, es decir, pertenecientes a $V_N$: 
	\begin{itemize}
	\item Primeras letras mayúsculas del alfabeto latino: \{{\em A, B, C, $\dots$ }\}
	\item Palabras en {\em cursiva} o encerradas entre ``$<$'' y ``$>$'': \{{\em término}, $<$t\'ermino$>$, $\dots$\} 
	\item La parte izquierda de la primera producci\'on ser\'a el símbolo inicial, salvo que se indique lo contrario. Generalmente, el símbolo inicial ser\'a el símbolo $S$. 
	\end{itemize}
\item Símbolos gramáticales terminales y no terminales, es decir, pertenecientes a $V = V_N \cup V_T$: 
	\begin{itemize}
	\item Últimas letras mayúsculas del alfabeto latino, salvo la letra $S$:\{{\em $\dots$ X, Y, Z }\}
	\end{itemize}
\item Cadenas de símbolos gramáticales terminales (pertenecientes a $V_T^*$) 
	\begin{itemize}
	\item Últimas letras minúsculas del alfabeto latino:\{{\em $\dots$ x, y, z }\}
	\end{itemize}
\item Los símbolos $\epsilon$ y $\lambda$ suelen denotar a la palabra vacía. 
\item Cadenas de símbolos gramáticales, es decir, compuestas por símbolos terminales y no terminales (pertenecientes a $V^* = (V_N \cup V_T)^*$.
	\begin{itemize}
	\item Letras minúsculas del alfabeto griego:\{{\em $\alpha, \beta, \gamma \dots$}\}
	\end{itemize}

\item Agrupamiento de reglas: si existen dos o m\'as reglas que tienen la misma parte izquierda, como, por ejemplo:
\begin{eqnarray*}
 \alpha & \longrightarrow & \beta_1 \\
 \alpha & \longrightarrow & \beta_2 \\
  & \cdots \\
 \alpha & \longrightarrow & \beta_n 
\end{eqnarray*}
entonces se pueden agrupar como 
$$\alpha \longrightarrow \beta_1 \hspace{1ex} | \hspace{1ex} \beta_2 \hspace{1ex} | \hspace{1ex} \cdots  \hspace{1ex} | \hspace{1ex} \beta_n $$
\end{enumerate}

\section{Tipos de gramáticas formales: jerarquía de Chomsky}

 Noam Chomsly utilizó la forma de las reglas de producción para proponer una clasificación de las gramáticas formales:
\begin{itemize}
\item Gramáticas de tipo 0, con estructura de frase o no restringidas.
\item Gramáticas de tipo 1 o sensibles al contexto.
\item Gramáticas de tipo 2, independientes del contexto o de contexto libre.
\item Gramáticas de tipo 3 o regulares.
\end{itemize}
 
 Esta clasificación introduce una jerarquía entre las gramáticas formales y, por tanto, entre los lenguajes formales generados por dichas gramáticas, así como entre las máquinas que reconocen dichos lenguajes.

\subsection{Gramáticas de tipo 0, con estructura de frase o no restringidas}\label{subsec-gramatica-no-restringida}

\begin{definicion} 
 Las {\bf\em gramáticas de tipo 0, con estructura de frase o no restringidas} se caracterizan porque sus producciones son de la forma:
$$\alpha \longrightarrow \beta \in P$$
donde
\begin{equation}
\begin{array}{l}
   \alpha = \delta A \gamma \\
  A \in V_N  \\
 \delta, \gamma, \beta \in V^* 
\end{array}
\end{equation}
\end{definicion} 

 Por tanto, la única restricción es que en la parte izquierda de las reglas debe haber al menos un símbolo no terminal. Respecto a las partes derechas, no hay ningún tipo de restricción.

\begin{ejemplo}\label{ejemplo-tipo-0} Conjunto de reglas de producción de una gramatica no restringida\footnote{Se han numerado las producciones para poderlas referenciar posteriormente.}.
\begin{eqnarray*}
    P & = & \{ \\
    & (1) & A \longrightarrow a A B C \\
    & (2) & A \longrightarrow a b C \\
    & (3) & A \longrightarrow \epsilon \\ 
    & (4) & C B \longrightarrow B C \\ 
    & (5) & b B \longrightarrow b b\\ 
    & (6) & b C \longrightarrow b \\
     &    & \}
\end{eqnarray*}
\end{ejemplo}


 Las gramáticas con estructura de frase generan los lenguajes recursivamente enumerables, los cuales son reconocidos por las máquinas de Turing.

\subsection{Gramáticas de tipo 1 o sensibles al contexto}\label{subsec-gramatica-sensible-contexto}

\begin{definicion} 
 Las {\bf\em gramáticas de tipo 1 o sensibles al contexto} se caracterizan porque sus producciones son de la forma:
$$\alpha \longrightarrow \beta \in P$$
donde
\begin{equation}
\begin{array}{l}
   |\alpha| \leq |\beta| \\
   \alpha = \delta A \gamma \\
  A \in V_N  \\
 \delta, \gamma \in V^* \\
  \beta \in V^+ 
\end{array}
\end{equation}
\end{definicion} 

 Como se puede observar, este tipo de gramáticas introduce la restricción de que la parte izquierda de la regla ha de tener una longitud\footnote{$|\alpha|$ y $|\beta|$ representan las longitudes de $\alpha$ y $\beta$, respectivamente.} igual o inferior a la de la parte derecha. Sólo se permite una excepción: se admite la regla $ S \longrightarrow \epsilon$ siempre que símbolo inicial $S$ no aparezca en la parte derecha de ninguna regla de la gramática.
 
Estas gramáticas se denominan ``sensibles al contexto'' porque son equivalentes a gramáticas compuestas por reglas que poseen la siguiente forma:
$$\delta A \gamma \longrightarrow \delta \beta \gamma \in P$$
donde
\begin{equation}
\begin{array}{l}
  A \in V_N  \\
 \delta, \gamma \in V^* \\
  \beta \in V^+ 
\end{array}
\end{equation}
 
 Un símbolo $A$ sólo se podrá sustituir por $\beta$ siempre y cuando se encuentre en el contexto que delimitan $\delta$ y $\gamma$.

\begin{ejemplo}\label{ejemplo-tipo-1} Conjunto de producciones de una gramática sensible al contexto.
\begin{eqnarray*}
    P & = & \{ \\
    & (1) & S \longrightarrow a S B C \\
    & (2) & S \longrightarrow a B C \\
    & (3)  & C B \longrightarrow B C \\ 
    & (4)  & a B \longrightarrow a b \\ 
    & (5)  & b B \longrightarrow b b \\ 
    & (6)  & b C \longrightarrow b c  \\
    & (7)  & c C \longrightarrow c c  \\
    &  & \}
\end{eqnarray*}
\end{ejemplo}

 Estas gramáticas generan los lenguajes sensibles al contexto, que son reconocidos por los autómatas lineales acotados.

\subsection{Gramáticas de tipo 2, independientes del contexto o de contexto libre}\label{subsec-gramatica-contexto-libre}

\begin{definicion} 
 Las {\bf\em gramáticas de tipo 2, independientes del contexto o de contexto libre} se caracterizan porque sus producciones son de la forma:
$$ A \longrightarrow \beta \in P$$
donde
\begin{equation}
\begin{array}{c}
  A \in V_N  \\
  \beta \in V^* 
\end{array}
\end{equation}
\end{definicion} 

 Este tipo de gramáticas es muy fácil de identificar, porque sus reglas sólo poseen un único símbolo no terminal en su parte izquierda y cero o más símbolos gramaticales (terminales o no terminales) en su parte derecha.

\begin{ejemplo} Conjunto de producciones de una gramática de contexto libre.
\begin{eqnarray*}
  P & = & \{ \\
    &   & S \longrightarrow \mbox{\bf\em identificador} = E \\
    &   & E \longrightarrow E + T \\
    &   & E \longrightarrow T \\
    &   & T \longrightarrow T * F \\
    &   & T \longrightarrow F \\
    &   & F \longrightarrow  ( E ) \\ 
    &   & F \longrightarrow \mbox{\bf\em identificador} \\ 
    &   & F \longrightarrow \mbox{\bf\em número} \\ 
    &   & \}
\end{eqnarray*}
\end{ejemplo}

 Estas gramáticas generan los lenguajes independientes del contexto o de contexto libre, que son reconocidos por los autómatas con pila.

\subsection{Gramáticas de tipo 3 o regulares}\label{subsec-tipo-tres}

\begin{definicion} 
Las {\bf\em gramáticas de tipo 3 o regulares} son las más restrictivas ya que sus reglas tienen la siguiente forma:
$$ A \longrightarrow \beta \in P$$
donde
\begin{equation}
\begin{array}{l}
  A \in V_N \\
  \beta  = \left\{\begin{array}{rrr}
                 a B & & B \in V_N \\ 
                 a & & a \in V_T \\ 
                 \epsilon 
                 \end{array}
           \right. 
\end{array}
\end{equation}
\end{definicion} 

\begin{ejemplo}Conjunto de producciones de una gramática regular.
\begin{eqnarray*}
  P & = & \{ \\
    &   & S \longrightarrow \mbox{\bf\em letra } \\
    &   & S \longrightarrow \mbox{\bf\em letra } A \\
    &   & A \longrightarrow \mbox{\bf\em letra } \\
    &   & A \longrightarrow \mbox{\bf\em letra } A \\
    &   & A \longrightarrow \mbox{\bf\em dígito } \\
    &   & A \longrightarrow \mbox{\bf\em dígito } A \\
    &   & \}
\end{eqnarray*}
\end{ejemplo}

 Estas gramáticas generan los lenguajes regulares, los cuales son reconocidos por los autómatas finitos.

\subsection{Jerarquía de las gram\'aticas}

 La definición de los diferentes tipos de gramáticas permite establecer la siguiente jerarquía (figura \ref{fig-jerarquia-gramaticas}):
\begin{equation}
 G_3 \subset G_2 \subset G_1 \subset G_0 
\end{equation}

\begin{figure}[htb]
\centerline{
\psfig{file=figuras/gramaticas/gramaticas.pdf,width=8.25cm} 
}
\caption{Jerarquía de las gramáticas formales.}\label{fig-jerarquia-gramaticas}
\end{figure}

\section{Generación de palabras: derivaciones}\label{sec-gramatica-derivacion}

 Las gramáticas formales generan las palabras de los lenguajes mediante ``derivaciones''. Una derivación se compone de cero o m\'as derivaciones inmediatas.

\begin{definicion}
 Si $G$ es una gramática formal, $\alpha \longrightarrow \beta \in P$ y $\delta \alpha \gamma \in V^+$ entonces 
\begin{equation}
\delta \alpha \gamma \Dflecha_G \delta \beta \gamma
\end{equation}
es una {\bf\em derivación inmediata}.
\end{definicion}
 
 Se requiere que la cadena $\alpha$  contenga al menos un símbolo no terminal porque representa la parte izquierda de una regla de una gramática.

\begin{ejemplo}
 Si consideramos la regla (5) {\em b B $\longrightarrow$ b b} de la gramática no restringida del ejemplo \ref{ejemplo-tipo-0}, se puede obtener la siguiente derivación inmediata
\begin{center}
  a a \underline{ b B} C $\Dflecha_5$  a a \underline{b b} C
\end{center}
\end{ejemplo}

\begin{definicion}
 Una {\bf\em derivación} es una secuencia de cadenas $\alpha_0, \alpha_1, \dots, \alpha_n \hspace{1ex}(n \geq 0)$, de forma que la cadena $\alpha_{i+1}$ se obtiene mediante una derivación inmediata de la cadena $\alpha_i \hspace{1ex} (0 \leq i \leq n-1)$, es decir,
\begin{equation}
 \alpha_i \Dflecha_G\alpha_{i+1}
\end{equation}
\end{definicion}

Encadenando todas las derivaciones inmediatas, se tiene que 
\begin{equation}
 \alpha_0 \Dflecha_G \alpha_1 \Dflecha_G \alpha_2 \Dflecha_G \cdots \Dflecha_G \alpha_i \Dflecha_G \alpha_{i+1} \Dflecha_G \cdots \Dflecha_G \alpha_n
\end{equation}
o, abreviadamente,
\begin{equation}
\alpha_0 \Dflecha_G^* \alpha_n
\end{equation}
 indicando que $\alpha_0$ deriva a $\alpha_n$ en cero o m\'as pasos o derivaciones inmediatas.

 Las cadenas de símbolos $\alpha_0, \alpha_1, \dots, \alpha_n (n \geq 0)$ que forman parte de una derivación se denominan {\bf\em ``formas sentenciales''}. Si una forma sentencial está compuesta exclusivamente por símbolos terminales, se denomina {\bf\em ``sentencia''}.
 
Si $n \geq 1$ entonces 
\begin{equation}
 \alpha_0 \Dflecha_G^+ \alpha_n
\end{equation}
En este caso, $\alpha_0$ deriva a $\alpha_n$ en uno o m\'as pasos o derivaciones inmediatas.

Si 
\begin{equation}
 \alpha \Dflecha_G^n \beta
\end{equation}
entonces se dice que $\alpha$ deriva a $\beta$ en $n$ pasos o derivaciones inmediatas.

Se verifica, además, que 
\begin{equation}
\alpha \Dflecha^0 \alpha \hspace{2ex} \forall \alpha \in V^*
\end{equation}

 Una derivación es:
\begin{itemize}
\item {\bf\em inicial} si $\alpha_0 = S$.
\item {\bf\em terminal} o {\bf\em final} si a partir de $\alpha_n$ no se puede aplicar ninguna regla de la gramática.
\end{itemize}


\begin{ejemplo}
Ejemplo de derivación\footnote{Los subíndices denotan las reglas de producción utilizadas en los pasos de la derivación, mientras que los superíndices (si aparecen) indican el número de veces que se aplican dichas reglas de producción.} utilizando la gramática no restringida del ejemplo \ref{ejemplo-tipo-0}:
\begin{eqnarray*}
  A  & \Dflecha_1 & a A B C\\
     & \Dflecha_2 & a a b C B C \\
     & \Dflecha_6 & a a b B C \\
     & \Dflecha_5 & a a b b C \\
     & \Dflecha_6 & a a b b
\end{eqnarray*}
\end{ejemplo}

\section{Lenguaje generado por una gramática}

\begin{definicion}
 El {\bf\em lenguaje generado por una gramática} se denota por $L(G)$ y se define como 
\begin{equation}
 L(G) = \{ x | x \in V_T^* \wedge S \Dflecha^+_G x \}
\end{equation}
es decir, $L(G)$ es el conjunto de todas las sentencias que se pueden obtener mediante derivaciones iniciales o el conjunto de todas las cadenas o palabras que se pueden derivar a partir del símbolo inicial de la gramática.
\end{definicion}

El lenguaje que genera una gramática regular puede ser descrito o denotado por las expresiones regulares.

 Generalmente, es muy difícil saber cómo es el lenguaje que genera una gramática que no sea regular, porque no existe ningún algoritmo que permite determinar cómo es dicho lenguaje. Algunas veces se puede deducir el lenguaje que generan algunas gramáticas no regulares relativamente simples, como la que se muestra en el siguiente ejemplo. 

\begin{ejemplo}
 Considérese la gramática sensible al contexto del ejemplo \ref{ejemplo-tipo-1}  que permite generar el siguiente lenguaje:
$$L(G) = \{ a^n b^n c^n | n \geq 1 \} = \{abc, aabbcc, aaabbbccc, \dots \}$$

 Comprobemos que la gramática permite derivar las palabras $a^nb^nc^n$ $\forall n\geq 1$:
\begin{itemize}
\item {\bf Base}: si $n = 1$
\begin{eqnarray*}
  S  & \Dflecha_2 &  a B C\\
     & \Dflecha_4 & a b C \\
     & \Dflecha_6 & a b c
\end{eqnarray*}

\item {\bf Inducción}: si $n \geq 2$
\begin{eqnarray*}
 S  & \Dflecha_1^{n-1}              & a^{n-1} S (B C)^{n-1}\\
    & \Dflecha_2                    & a^n (B C)^n \\
    & \Dflecha_3^{\frac{(i-1)i}{2}} & a^n B^n C^n\\
    & \Dflecha_4                    & a^n b B^{n-1} C^n\\
    & \Dflecha_5^{n-1}              & a^n b^n C^n\\
    & \Dflecha_6                    & a^n b^n c C^{n-1}\\
    & \Dflecha_7^{n-1}              & a^n b^n c^n
\end{eqnarray*}

\end{itemize}
\end{ejemplo}

\begin{definicion}
Se dice que dos {\bf\em gramáticas son equivalentes} si y sólo si generan el mismo lenguaje, es decir,
\begin{equation}
  G_1 \equiv G_2 \leftrightarrow L(G_1) = L(G_2)
\end{equation}
\end{definicion}

 
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Gramáticas de contexto libre}

\subsection{Definición}\label{sec-definicion-gramatica-contexto-libre}

\begin{definicion}
 Una {\bf\em gramática de contexto libre, independiente del contexto o de tipo 2} es una gramática formal\footnote{Véanse la sección \ref{sec-gramatica-formal} y la subsección \ref{subsec-gramatica-contexto-libre}.} cuyas sus reglas de producción son de la forma:
$$ A \longrightarrow \beta \in P$$
donde
\begin{equation}
\begin{array}{c}
  A \in V_N  \\
  \beta \in V^* 
\end{array}
\end{equation}
\end{definicion}

 Como se puede observar, cada regla de producción de una gramática de contexto libre posee un símbolo no terminal en su parte izquierda y cero o más símbolos terminales o no terminales en su parte derecha. Como consecuencia de esta definición, todas las gramáticas regulares son también gramáticas de contexto libre. Las gramáticas de contexto libre generan los lenguajes de contexto libre que son reconocidos por los autómatas con pila.

\begin{ejemplo}\label{ejemplo-gramatica-expresiones1} Sea la gramática de contexto libre $G = (V_N, V_T,P,S)$ donde
\begin{itemize}
\item $V_N = \{S, E\}$,
\item $V_T = \{\mbox{\bf\em identificador}, =, +, *, (, ), \mbox{\bf\em número}\}$, 
\item $S \in V_N$ 
\item y el conjunto de producciones es:
\begin{eqnarray*}
   P & = & \{ \\
     & (1) & S \longrightarrow \mbox{\bf\em identificador } = \hspace{1ex} E \\
     & (2) & E \longrightarrow E \hspace{1ex} + \hspace{1ex} E \\
     & (3) & E \longrightarrow E \hspace{1ex} * \hspace{1ex} E \\
     & (4) & E \longrightarrow ( \hspace{1ex} E \hspace{1ex} ) \\
     & (5) & E \longrightarrow \mbox{\bf\em identificador} \\
     & (6) & E \longrightarrow \mbox{\bf\em número} \\ 
     &   &\}
\end{eqnarray*}
\end{itemize}
\end{ejemplo}

 Las gramáticas de contexto libre son utilizadas para establecer las reglas sintácticas de los lenguajes de programación.

\begin{ejemplo}
Conjunto de reglas de producción de una gramática que permite generar algunas sentencias de control de un lenguaje de programación:
\begin{eqnarray*}
   P & = & \{ \\
     &   & S \longrightarrow \mbox{\bf\em mientras } C \hspace{1ex} \mbox{\bf\em hacer } S \hspace{1ex} \mbox{\bf\em fin\_mientras} \\
     &   & S \longrightarrow \mbox{\bf\em si } C \hspace{1ex} \mbox{\bf\em entonces } S \hspace{1ex} \mbox{\bf\em fin\_si} \\
     &   & S \longrightarrow \mbox{\bf\em si } C \hspace{1ex} \mbox{\bf\em entonces } S \hspace{1ex} \mbox{\bf\em si\_no } S \hspace{1ex} \mbox{\bf\em fin\_si} \\
     &   & S \longrightarrow \mbox{\bf\em Asignación} \\
     &   & C \longrightarrow \mbox{\bf\em Condición} \\
     &   & \}
\end{eqnarray*}
\end{ejemplo}

\subsection{Derivación con una gramática de contexto libre}\index{Gramática!de Contexto libre!Derivación con una}

 El concepto de derivación, definido en la sección \ref{sec-gramatica-derivacion}, tiene siguientes características si se aplica a una gramática de contexto libre.


\begin{definicion}
Si $G = (V_N,V_T,P,S)$ es una gramática de contexto libre, $\delta A \eta$ es una cadena de símbolos donde $A \in V_N$ y $\delta, \eta \in V^*$ y $A \longrightarrow \beta$ es una regla de producción de la gramática entonces
\begin{equation}  
   \delta A \eta \Dflecha_G \delta \beta \eta 
\end{equation}  
 es una {\bf\em derivación inmediata} realizada una producción de la gramática $G$.
\end{definicion}

Una derivación inmediata de una gramática de contexto libre sólo sustituye un símbolo no terminal por una cadena de símbolos que formen la parte derecha de alguna de sus reglas.

\begin{definicion}
 Una {\bf\em derivación} es una secuencia de cadenas $\alpha_0, \alpha_1, \dots, \alpha_n$ $(n \geq 0)$, de forma que la cadena $\alpha_{i+1} = \delta \beta_i \eta$ se obtiene mediante una derivación inmediata de la cadena $\alpha_i = \delta A_i \eta \hspace{1ex} (0 \leq i \leq n-1)$, es decir,
\begin{equation}
 \alpha_i = \delta  A_i \eta \Dflecha_G \delta \beta_i \eta = \alpha_{i+1} 
\end{equation}
donde $A_i \in V_N$ y $\delta,\eta,\beta_i \in V^*$.

Encadenando todas las derivaciones inmediatas, se tiene que 
\begin{equation}
 \alpha_0 \Dflecha_G \alpha_1 \Dflecha_G \alpha_2 \Dflecha_G \dots \Dflecha_G \alpha_i \Dflecha_G  \alpha_{i+1} \Dflecha_G  \dots \Dflecha_G  \alpha_n
\end{equation}
o, abreviadamente,
\begin{equation}
\alpha_0 \Dflecha^*_G \alpha_n
\end{equation}
 indicando que $\alpha_0$ deriva a $\alpha_n$ en cero o m\'as pasos o derivaciones inmediatas.

\begin{itemize}
\item Siempre se verifica que 
\begin{equation}
 \alpha \Dflecha^0_G \alpha
\end{equation}
\item Si $n \geq 1$ entonces 
\begin{equation}
 \alpha_0 \Dflecha^+_G \alpha_n
\end{equation}
En este caso, $\alpha_0$ deriva a $\alpha_n$ en uno o m\'as pasos o derivaciones inmediatas.
\item Si 
\begin{equation}
 \alpha \Dflecha^n_G \beta
\end{equation}
entonces se dice que $\alpha$ deriva a $\beta$ en $n$ pasos o derivaciones inmediatas.
\item Una {\bf\em derivación} es {\bf\em inicial} si $\alpha_0 = S$.
\item Una {\bf\em derivación} es {\bf\em terminal} si a partir de $\alpha_n$  no se puede aplicar ninguna regla de la gramática.
\end{itemize}
\end{definicion}

\begin{ejemplo}\label{ejemplo-derivacion-gramatica-contexto-libre}
La gramática del ejemplo \ref{ejemplo-gramatica-expresiones1} permite generar la siguiente derivación:
\begin{eqnarray*}
  S  & \Dflecha_1 & \mbox{\bf\em identificador } = \hspace{1ex} E \\
     & \Dflecha_2 & \mbox{\bf\em identificador } = \hspace{1ex} E \hspace{1ex} + \hspace{1ex} E \\
     & \Dflecha_3 & \mbox{\bf\em identificador } = \hspace{1ex} E \hspace{1ex} + \hspace{1ex} E \hspace{1ex} * \hspace{1ex} E \\
     & \Dflecha_6 & \mbox{\bf\em identificador } = \hspace{1ex} E \hspace{1ex} + \hspace{1ex} \mbox{\bf\em número } * \hspace{1ex} E \\
     & \Dflecha_5 & \mbox{\bf\em identificador } = \hspace{1ex} E \hspace{1ex} + \hspace{1ex} \mbox{\bf\em número } * \hspace{1ex} \mbox{\bf\em identificador }  \\
     & \Dflecha_5 & \mbox{\bf\em identificador } = \mbox{\bf\em identificador } + \hspace{1ex} \mbox{\bf\em número } * \hspace{1ex} \mbox{\bf\em identificador } 
\end{eqnarray*}
\end{ejemplo}

\begin{definicion}
 Se dice que una {\bf\em derivación} $\alpha_0, \alpha_1, \dots, \alpha_n \hspace{1ex} (n \geq 0)$, es por la {\bf\em izquierda} si $\forall i \in \{0, \dots, n-1\} \hspace{1ex} \exists A_i \longrightarrow \beta \in P$  tal que
\begin{equation}
 \alpha_i = x  A_i \eta \Dflecha_I x \beta_i \eta = \alpha_{i+1} 
\end{equation}
 donde $x \in V^*_T, A_i \in V_N$ y $\eta, \beta \in V^* = (V_N \cup V_T)^*$
\end{definicion}

 Las derivaciones por la izquierda siempre aplican, en cada paso o derivación inmediata, una regla asociada al símbolo no terminal situado más a la izquierda. La definición de derivación por la derecha es análoga.

\begin{ejemplo}\label{ejemplo-derivacion-expresiones}
La gramática del ejemplo \ref{ejemplo-gramatica-expresiones1} permite generar la siguiente derivación por la izquierda:

\begin{eqnarray*}
  S  & \Dflecha_1 & \mbox{\bf\em identificador } = \hspace{1ex} E \\
     & \Dflecha_2 & \mbox{\bf\em identificador } = \hspace{1ex} E \hspace{1ex} + \hspace{1ex} E \\
     & \Dflecha_5 & \mbox{\bf\em identificador } = \mbox{\bf\em identificador} \hspace{1ex} + \hspace{1ex} E \\
     & \Dflecha_3 & \mbox{\bf\em identificador } = \mbox{\bf\em identificador }  + \hspace{1ex} E \hspace{1ex} * \hspace{1ex} E \\
     & \Dflecha_6 & \mbox{\bf\em identificador } = \mbox{\bf\em identificador } + \hspace{1ex} \mbox{\bf\em número } * \hspace{1ex} E \\
     & \Dflecha_5 & \mbox{\bf\em identificador } = \mbox{\bf\em identificador } + \hspace{1ex} \mbox{\bf\em número } * \hspace{1ex} \mbox{\bf\em identificador } 
\end{eqnarray*}
\end{ejemplo}

\begin{teorema}
  Si existe una derivación
$$ A \Dflecha^n x$$
donde $A \in V_N$ y $x \in V^*_T$ entonces se puede construir otra derivación por la izquierda\footnote{El teorema para las derivaciones por la derecha es similar.} $$ A \Dflecha_I^n x$$
\end{teorema}

\raisebox{0.75ex}{\fbox{}}
{\bf Demostración}

 La demostración se va a realizar por inducción sobre el número de pasos de la derivación:
\begin{enumerate}
\item {\bf Base}: si $n = 1$ entonces la gramática ha de contener una regla de la forma $A \longrightarrow x \in P$, lo que permite generar la siguiente derivación por la izquierda en un paso o derivación inmediata: $$A \Dflecha^1_I x$$ 
\item {\bf Inducción}: supóngase que el teorema se verifica para todas las derivaciones con un número de pasos menor o igual que $k$ y sea $A \Dflecha^{k+1} x$ una derivación en $k+1$ pasos con $k \leq n$. Esta derivación se puede descomponer en  
\begin{eqnarray*}
  A & \Dflecha^1 & X_1 X_2 \dots X_m \\
    & \Dflecha^k & x_1 x_2 \dots x_m \\
    & = &  x
\end{eqnarray*}
donde $k = k_1 + k_2 + \dots + k_m$ y $\forall i\in \{1,\dots,m\}$ 
\begin{itemize}
\item $X_i \in V = (V_N \cup V_T)$
\item $x_i \in V^*_T$ 
\item $X_i \Dflecha^{k_i} x_i$  
\item $0 \leq k_i \leq m$
\end{itemize}
 
 Dependiendo de la naturaleza de cada símbolo $X_i$, se presentan dos posibilidades:
	\begin{enumerate}
	\item Si $X_i \in V_N$ entonces se puede aplicar la hipótesis de inducción, puesto que $k_i \leq k \leq n$, que afirma que existe una derivación por la izquierda:
\begin{equation}
 X_i \Dflecha^{k_i}_I x_i
\end{equation} 
	\item Si $X_i \in V_T$ entonces $X_i = x_i \in V_T$ y existe una derivación por la izquierda que permite que un símbolo terminal se derive a sí mismo en cero pasos:
\begin{equation} 
   X_i = x_i \Dflecha^0_I x_i
\end{equation}
	\end{enumerate}
\end{enumerate}

Enlazando las nuevas derivaciones por la izquierda, se puede construir la siguiente derivación por la izquierda que deriva la cadena $x$ desde el símbolo $A$:
\begin{eqnarray*}
  A & \Dflecha^1 & X_1 X_2 \dots X_m \\
    & \Dflecha^{k_1}_I & x_1 X_2 \dots X_m \\
    & \Dflecha^{k_2}_I & x_1 x_2 \dots X_m \\
    &  \cdots & \\
    & \Dflecha^{k_m}_I & x_1 x_2 \dots x_m \\
    & = &  x
\end{eqnarray*}
\hfill\rule{1.5ex}{1.5ex}

\subsection{Árbol de derivación}\index{Gramática!de Contexto libre!Árbol de derivación con una}

\begin{definicion}
El {\bf\em arbol de derivación} asociado a una derivación {\bf\em de una gramática de contexto libre} es un árbol sintáctico que posee las siguientes características:
\begin{enumerate}
\item Los nodos del árbol están etiquetados con símbolos gramaticales (terminales o no terminales) o con la palabra vacía.
\item La raíz del árbol está etiquetada con el símbolo inicial de la gramática.
\item Si un nodo tiene al menos un descendiente, le corresponde como etiqueta un símbolo no terminal.
\item Si tenemos un nodo etiquetado con $A$ y se ha aplicado la regla $A \longrightarrow X_1 X_2 \dots X_k$, donde $X_i \in V \cup \{\epsilon\} \hspace{1ex} \forall i \in \{1,2,\dots,k\}$, entonces dicho nodo tendrá $k$ descendientes inmediatos (``hijos'') etiquetados con los símbolos $X_1, X_2, \dots, X_k$.
\end{enumerate}
\end{definicion}

\begin{ejemplo} La figura \ref{fig-arbol-derivacion-gramatica-contexto-libre} muestra el árbol correspondiente a la derivación del ejemplo \ref{ejemplo-derivacion-expresiones}.

\begin{figure}[htb]
\centerline{
\psfig{file=figuras/gramaticas-contexto-libre/arbol-derivacion-gramatica-contexto-libre.pdf,width=5cm} 
}
\caption{Ejemplo de árbol de derivación de una gramática de contexto libre.}\label{fig-arbol-derivacion-gramatica-contexto-libre}
\end{figure}
\end{ejemplo}

 En la subsección \ref{subsec-chomsky} se muestra cómo las gramáticas de contexto libre que están en la forma normal de Chomsky poseen árboles de derivación binarios.

\subsection{Lenguaje generado por una gramática de contexto libre}\index{Gramática!de Contexto libre!Lenguaje generado por una}

\begin{definicion}
 El {\bf\em lenguaje generado por una gramática de contexto libre} $G$ es
\begin{equation}
	L(G) = \{x | x \in V^*_T \wedge S \Dflecha^+_G x\}
\end{equation}
\end{definicion}

Por tanto, el lenguaje generado por una gramática de contexto libre está formado por palabras formadas por símbolos terminales que se obtienen derivando el símbolo inicial una o más veces.

Las gramáticas de contexto libre y los autómatas con pila son equivalentes, lo cual servirá para comprobar si una palabra pertenece o no al lenguaje que reconoce el autómata y, por tanto, al lenguaje que genera la gramática.

Por el contrario, no existe ningún algoritmo genérico que permita determinar cuál es el lenguaje generado por una gramática de contexto libre, aunque hay casos excepcionales en los que sí es posible, tal y como se muestra en el siguiente ejemplo.

\begin{ejemplo}\label{ejemplo-gramatica-ai-bi}
 Sea $G$ una gramática de contexto libre compuesta por el siguiente conjunto de reglas de producción:
\begin{eqnarray*}
   P & = & \{ \\
     & (1) & S \longrightarrow a A a \\
     & (2) & A \longrightarrow a A a \\
     & (3) & A \longrightarrow b B b \\
     & (4) & B \longrightarrow b B b \\
     & (5) & B \longrightarrow c \\
     &   &\}
\end{eqnarray*}

 El lenguaje que genera la gramatica $G$ puede ser expresado como:
\begin{eqnarray*}
  L(G) & = & \{ a^ib^jcb^ja^i | i, j \geq 1\} \\
       & = & \{aca, abcba, abbcbba, \dots, aacaa, aabbcbbaa, \dots \} 
\end{eqnarray*}

 Este lenguaje se denomina ``palíndromo impar'' porque cada una de las palabras del lenguaje se puede leer igual de izquierda a derecha que de derecha a izquierda y tiene un elemento central que divide a la palabra.

 La derivación que genera la palabra $aabbcbbaa$ es la siguiente:
\begin{eqnarray*}
  S  & \Dflecha_1 & a A a \\
     & \Dflecha_2 & a a A a a \\
     & \Dflecha_3 & a a b B b a a \\
     & \Dflecha_4 & a a b b B b b a a \\
     & \Dflecha_5 & a a b b c b b a a 
\end{eqnarray*}
\end{ejemplo}


\subsection{Ambigüedad}

\subsubsection{Definición}

\begin{definicion}
 Se dice que una {\bf\em gramática es ambigua} si el lenguaje que genera contiene alguna palabra que cumple alguna de las siguientes condiciones:
\begin{itemize}
\item Puede ser generada por al menos dos derivaciones cuyos árboles sin\-tác\-ti\-cos son diferentes.
\item Puede ser generada por al menos dos derivaciones por la izquierda diferentes.
\item Puede ser generada por al menos dos derivaciones por la derecha diferentes.
\end{itemize}
\end{definicion}

\begin{ejemplo} 
 La gramática \ref{ejemplo-gramatica-expresiones1} es ambigua porque puede generar la cadena $$\mbox{\bf\em identificador = identificador + número * identificador}$$ mediante dos derivaciones por la izquierda diferentes. La primera derivación por la izquierda se mostró en el ejemplo \ref{ejemplo-derivacion-expresiones}. La segunda derivación por la izquierda se muestra a continuación:
\begin{eqnarray*}
  S  & \Dflecha_1 & \mbox{\bf\em identificador } = \hspace{1ex} E \\
     & \Dflecha_2 & \mbox{\bf\em identificador } = \hspace{1ex} E \hspace{1ex} * \hspace{1ex} E \\
     & \Dflecha_3 & \mbox{\bf\em identificador } = \hspace{1ex} E \hspace{1ex} + \hspace{1ex} E \hspace{1ex} * \hspace{1ex} E \\
     & \Dflecha_5 & \mbox{\bf\em identificador } = \mbox{\bf\em identificador } + \hspace{1ex} E  * \hspace{1ex} E  \\
     & \Dflecha_5 & \mbox{\bf\em identificador } = \mbox{\bf\em identificador } + \hspace{1ex} \mbox{\bf\em número } * \hspace{1ex} E  \\
     & \Dflecha_5 & \mbox{\bf\em identificador } = \mbox{\bf\em identificador } + \hspace{1ex} \mbox{\bf\em número } * \hspace{1ex} \mbox{\bf\em identificador } 
\end{eqnarray*}
 
\begin{figure}[htb]
\centerline{
\psfig{file=figuras/gramaticas-contexto-libre/arbol-derivacion-gramatica-contexto-libre-2.pdf,width=8cm} 
}
\caption{Ejemplo de árbol de derivación de una gramática de contexto libre.}\label{fig-arbol-derivacion-gramatica-contexto-libre-2}
\end{figure}
\end{ejemplo}

Si se observan los árboles sintácticos asociados a la primera y a la segunda derivaciones (figuras \ref{fig-arbol-derivacion-gramatica-contexto-libre} y \ref{fig-arbol-derivacion-gramatica-contexto-libre-2}) se puede comprobar que son diferentes, lo cual corrobora el hecho de que la gramática \ref{ejemplo-gramatica-expresiones1} es ambigua. 
 
 Desde un punto de vista semántico, la única derivación correcta sería la primera, porque el producto se ha de evalúar antes que la suma.

 Determinar si una gramática es ambigua es un problema indecidible, porque no existe ningún un algoritmo que permita determinar si una gramática es ambigua o no, aunque haya casos relativamente sencillos, como el del ejemplo anterior, en los que sí se puede detectar la ambigüedad.

 El hecho de que una gramática de contexto libre sea ambigua no implica que el lenguaje que genera lo sea, ya que puede puede existir otra gramática no ambigua que también lo genere. El siguiente ejemplo muestra una gramática no ambigua que genera el mismo lenguaje que la gramática del ejemplo anterior.

\begin{ejemplo}\label{ejemplo-gramatica-expresiones-no-ambigua} Conjunto de reglas de producción de una gramática no ambigua que puede generar las expresiones aritméticas que genera la gramática del ejemplo \ref{ejemplo-gramatica-expresiones1}:

\begin{eqnarray*}
   P & = & \{ \\
     & (1) & S \longrightarrow \mbox{\bf\em identificador } = \hspace{1ex} E \\
     & (2) & E \longrightarrow E \hspace{1ex} + \hspace{1ex} T \\
     & (3) & E \longrightarrow T \\
     & (4) & T \longrightarrow T \hspace{1ex} * \hspace{1ex} F \\
     & (5) & T \longrightarrow F \\
     & (6) & F \longrightarrow ( \hspace{1ex} E \hspace{1ex} ) \\
     & (7) & F \longrightarrow \mbox{\bf\em identificador} 
\end{eqnarray*}
\begin{eqnarray*}
     & (8) & F \longrightarrow \mbox{\bf\em número} \\ 
     &   &\}
\end{eqnarray*}

Esta gramática no es ambigua porque cada expresión aritmética sólo puede ser generada utilizando un única derivación por la izquierda (derecha). 

La derivación por la izquierda de la cadena $$\mbox{\bf\em identificador = identificador + número * identificador}$$ utilizando esta gramática es la siguiente:
\begin{eqnarray*}
  S  & \Dflecha_1 & \mbox{\bf\em identificador } = \hspace{1ex} E \\
     & \Dflecha_2 & \mbox{\bf\em identificador } = \hspace{1ex} E \hspace{1ex} + \hspace{1ex} T \\
     & \Dflecha_3 & \mbox{\bf\em identificador } = \hspace{1ex} T \hspace{1ex} + \hspace{1ex} T \\
     & \Dflecha_5 & \mbox{\bf\em identificador } = \hspace{1ex} F \hspace{1ex} + \hspace{1ex} T \\
     & \Dflecha_7 & \mbox{\bf\em identificador } = \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} + \hspace{1ex} T \\
     & \Dflecha_4 & \mbox{\bf\em identificador } = \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} + \hspace{1ex} T \hspace{1ex} * \hspace{1ex} F \\
     & \Dflecha_5 & \mbox{\bf\em identificador } = \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} + \hspace{1ex} F \hspace{1ex} * \hspace{1ex} F \\
     & \Dflecha_8 & \mbox{\bf\em identificador } = \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} + \hspace{1ex} \mbox{\bf\em número} \hspace{1ex} * \hspace{1ex} F \\
     & \Dflecha_7 & \mbox{\bf\em identificador } = \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} + \hspace{1ex} \mbox{\bf\em número} \hspace{1ex} * \hspace{1ex} \mbox{\bf\em identificador} 
\end{eqnarray*}
 
La figura \ref{fig-arbol-derivacion-gramatica-contexto-libre-3} muestra el árbol sintáctico asociado a esta derivación.

\begin{figure}[htb]
\centerline{
\psfig{file=figuras/gramaticas-contexto-libre/arbol-derivacion-gramatica-contexto-libre-3.pdf,width=9cm} 
}
\caption{Ejemplo de árbol de derivación de una gramática de contexto libre no ambigua.}\label{fig-arbol-derivacion-gramatica-contexto-libre-3}
\end{figure}
\end{ejemplo} 


\subsubsection{El problema del ``else danzante''}

 La ambigüedad está presente en los lenguajes de programación y un ejemplo claro es el problema del ``else danzante'' que consiste en determinar si una sentencia corresponde al consecuente o a la alternativa de una sentencia condicional.

 Considérese una gramática de contexto libre que contenga las siguientes reglas de producción que genera sentencias condicionales del lenguaje C:
$$
\begin{array}{llcl}
      &  &  \cdots & \\
  (1) & S & \longrightarrow & \mbox{\bf\em if } C  \hspace{1ex} S \\ 
  (2) & S & \longrightarrow & \mbox{\bf\em if } C  \hspace{1ex} S \hspace{1ex} \mbox{\bf\em else } S \\
  (3) & S & \longrightarrow & I \\ 
      &  &  \cdots &
\end{array}
$$
donde $S$ genera sentencias de control, $C$ genera expresiones condicionales e $I$ genera otras sentencias, por ejemplo, de asignación.

\begin{figure}[htb]
\centerline{
\begin{tabular}{cc}
\psfig{file=figuras/gramaticas-contexto-libre/else-danzante1.pdf,width=8cm} &  
\psfig{file=figuras/gramaticas-contexto-libre/else-danzante2.pdf,width=8cm}  \\ \\
 (a) & (b)
\end{tabular}
}
\caption{Problema del ``else danzante'':  árboles correspondientes a (a) la primera y  a (b) la segunda derivación.}\label{fig-else-danzante}
\end{figure}
 
Esta gramática es ambigua porque la sentencia 
\begin{equation}\label{eq-else-danzante}
\mbox{\bf\em if } C  \hspace{1ex} \mbox{\bf\em if } C  \hspace{1ex} S \hspace{1ex} \mbox{\bf\em else } S 
\end{equation}
puede ser generada mediante dos derivaciones que tienen dos árboles sintácticos diferentes (figura \ref{fig-else-danzante}):
\begin{enumerate}
\item Primera derivación:
\begin{eqnarray*}
   S & \Dflecha_1 & \mbox{\bf\em if } C  \hspace{1ex} \underline{S} \\ 
     & \Dflecha_2 & \mbox{\bf\em if } C  \hspace{1ex} \underline{\mbox{\bf\em if } C  \hspace{1ex} S \hspace{1ex} \mbox{\bf\em else } S}
\end{eqnarray*}
\item Segunda derivación:
\begin{eqnarray*}
   S & \Dflecha_2 & \mbox{\bf\em if } C  \hspace{1ex} \underline{S} \hspace{1ex} \mbox{\bf\em else } S \\ 
     & \Dflecha_1 & \mbox{\bf\em if } C  \hspace{1ex} \underline{\mbox{\bf\em if } C  \hspace{1ex} S} \hspace{1ex} \mbox{\bf\em else } S
\end{eqnarray*}
\end{enumerate}

 Puesto que el lenguaje C asosia el ``else'' al ``if más cercano'', la derivación correcta es la primera. Afortunadamente, se puede reescribir la gramática para que tenga en cuenta este criterio semántico: 
$$
\begin{array}{llcl}
      &  &  \cdots & \\
  (1) & S & \longrightarrow & S_1 \\ 
  (2) & S & \longrightarrow & S_2 \\ 
  (3) & S_1 & \longrightarrow & \mbox{\bf\em if } C \hspace{1ex} S_1 \hspace{1ex} \mbox{\bf\em else } S_1 \\
  (4) & S_1 & \longrightarrow & I \\ 
  (5) & S_2 & \longrightarrow & \mbox{\bf\em if } C  \hspace{1ex} S \\ 
  (6) & S_2 & \longrightarrow & \mbox{\bf\em if } C \hspace{1ex} S_1 \hspace{1ex} \mbox{\bf\em else } S_2 \\
      &  &  \cdots &
\end{array}
$$
donde $S_1$ genera la sentencia ``if emparejada'' mientras que $S_2$ genera la sentencia ``if no emparejada''.

La derivación de la cadena \ref{eq-else-danzante} utilizando estas reglas de producción es la siguiente:
\begin{eqnarray*}
   S & \Dflecha_2 & S_2 \\ 
     & \Dflecha_5 & \mbox{\bf\em if } C  \hspace{1ex} \underline{S} \\ 
     & \Dflecha_1 & \mbox{\bf\em if } C  \hspace{1ex} \underline{S_1} \\ 
     & \Dflecha_3 & \mbox{\bf\em if } C  \hspace{1ex} \underline{\mbox{\bf\em if } C  \hspace{1ex} S_1 \hspace{1ex} \mbox{\bf\em else } S_2}
\end{eqnarray*}

\begin{figure}[htb]
\centerline{
\psfig{file=figuras/gramaticas-contexto-libre/else-danzante3.pdf,width=8cm} 
}
\caption{Árbol sintáctico asociado a una derivación que asocia el ``else al if más cercano''.}\label{fig-else-danzante-2}
\end{figure}

\subsubsection{Lenguajes intrínsecamente ambiguos}

\begin{definicion}
 Un {\bf\em lenguaje de contexto libre es intrínsecamente ambiguo} si sólo se puede generar mediante gramáticas de contexto libre ambiguas. 
\end{definicion}

\begin{ejemplo}
 El siguiente lenguaje es un lenguaje de contexto libre intrínsecamente ambiguo porque todas las gramáticas de contexto libre que lo generan son ambiguas:
\begin{equation}
 L = \{a^ib^ic^j| i, j \geq 1 \} \cup \{a^ib^jc^j|i, j \geq 1\}
\end{equation}

 Este lenguaje es de contexto libre porque puede ser generado por una gramática de contexto libre como la siguiente:
\begin{eqnarray*}
   P & = & \{ \\
     & (1) & S \longrightarrow A C  \\
     & (2) & S \longrightarrow B D \\
     & (3) & A \longrightarrow a A b \\
     & (4) & A \longrightarrow a b \\
     & (5) & C \longrightarrow c C \\
     & (6) & C \longrightarrow c \\
     & (7) & B \longrightarrow a B \\
     & (8) & B \longrightarrow a \\
     & (9) & D \longrightarrow b D c \\
     & (10) & D \longrightarrow b c \\
     &   &\}
\end{eqnarray*}

Esta gramática es ambigua porque puede derivar la cadena $abc$ utilizando dos derivaciones por la izquierda diferentes:
\begin{enumerate}
\item Primera derivación:
\begin{eqnarray*}
   S & \Dflecha_1 & A C \\ 
     & \Dflecha_4 & a b C \\
     & \Dflecha_6 & a b c 
\end{eqnarray*}
\item Segunda derivación:
\begin{eqnarray*}
   S & \Dflecha_1 & B D \\ 
     & \Dflecha_4 & a D \\
     & \Dflecha_{10} & a b c 
\end{eqnarray*}
\end{enumerate}

La figura \ref{fig-inherente} muestra cómo los árboles sintáticcos correspondientes a estas dos derivaciones por la izquierda son diferentes.

\begin{figure}[htb]
\centerline{
\begin{tabular}{ccc}
\psfig{file=figuras/gramaticas-contexto-libre/arbol-inherente1.pdf,width=3cm} &  &
\psfig{file=figuras/gramaticas-contexto-libre/arbol-inherente2.pdf,width=3cm}  \\ \\
 (a) & \hspace{3ex} & (b)
\end{tabular}
}
\caption{Árboles de derivación diferentes de la cadena $abc$ correspondientes a (a) la primera y a (b) la segunda derivación.}\label{fig-inherente}
\end{figure}

\end{ejemplo}


 Es mucho más compleja la demostración de que todas la gramáticas de contexto libre que generan este lenguaje son ambiguas. El razonamiento se basa en que las cadenas de la forma $a^nb^nc^n$ siempre podrán ser generadas de dos formas diferentes, ya que todas las gramáticas deberán permitir la generación diferenciada de dos tipos de cadenas: en primer lugar, las cadenas que poseen el mismo número de aes que de bes y, en segundo lugar, las cadenas que poseen el mismo número de bes que de ces.



\subsection{Vacuidad de una gramática}

 Al diseñar una gramática, es necesario comprobar si genera o no un lenguaje vacío.
\begin{teorema}
  Una gramática de contexto libre $G = (V_N, V_T, P, S)$ genera un lenguaje no vacío si y sólo si se verifica alguna de las siguientes condiciones:
\begin{enumerate}
\item $\exists S \longrightarrow x \in P \wedge x \in V^*_T$
\item $\exists S \longrightarrow \alpha \in P \wedge \exists \alpha \Dflecha^* x \wedge x \in V^*_T$
\end{enumerate}
\end{teorema}
\raisebox{0.75ex}{\fbox{}}
{\bf Demostración}

\fbox{$\Leftarrow$}

\begin{enumerate}
\item Si $\exists S \longrightarrow x \in P \wedge x \in V^*_T$ entonces $S \Dflecha x \in P$ y $x \in L(G) \neq \emptyset$.  
\item Si $\exists S \longrightarrow \alpha \in P \wedge \exists \alpha \Dflecha^* x \wedge x \in V^*_T$ entonces $S \Dflecha \alpha \Dflecha^* x \in P$ y $x \in L(G) \neq \emptyset$.  
\end{enumerate}

\fbox{$\Rightarrow$}
 
 Si $L(G) \neq \emptyset$ entonces existe una derivación que genera una cadena de símbolos terminales: $S \Dflecha^+ x \wedge x \in V^*_T$. Supóngase que la derivación consta de $k$ pasos o derivaciones inmediatas:
\begin{enumerate}
\item Si $k = 1$ entonces $\exists S \longrightarrow x \in P \wedge x \in V^*_T$.
\item Si $k > 1$ entonces $\exists \alpha \in (V_T \cup V_T)^*$ tal que  $S \Dflecha \alpha \Dflecha^* x \in P$.
\end{enumerate}

\hfill\rule{1.5ex}{1.5ex}

 El siguiente algoritmo permite comprobar si una gramática genera o no un lenguaje vacío:

\begin{algoritmo}\label{algoritmo-vacuidad-gramatica-contexto-libre}{\bf\em Vacuidad del lenguaje generado por una gramática de contexto libre}
\newcount\algocount
\begin{algorithm}
{\bf\em inicio}
\ $Viejo \leftarrow \emptyset$
\ $Nuevo \leftarrow \{A | A \longrightarrow x \in P \wedge x \in V^*_T\}$
\ {\bf\em mientras} $(Nuevo \neq Viejo) y (S \notin Nuevo)$ {\bf\em hacer} 
\ \ $Viejo \leftarrow Nuevo$
\ \ $Nuevo \leftarrow Viejo \cup \{A | A \longrightarrow \alpha \in P \wedge \alpha \in (V_T \cup Viejo)^*\}$
\ {\bf\em fin mientras}
\ {\bf\em si}  $S \in Nuevo$
\ \ {\bf\em entonces} {\bf\em escribir}(``La gramática genera un lenguaje no vacío'')
\ \ {\bf\em si no} {\bf\em escribir}(``La gramática genera un lenguaje vacío'')
\ {\bf\em fin si}
{\bf\em fin}
\end{algorithm}
\end{algoritmo}

\begin{ejemplo} Sea $G$ una gramática con el siguiente conjunto de reglas de producción:
\begin{eqnarray*}
   P & = & \{ \\
     & (1)  & S \longrightarrow A B a \\ 
     & (2)  & A \longrightarrow B D b  \\
     & (3)  & A \longrightarrow E B \\
     & (4)  & B \longrightarrow C D \\
     & (5)  & C \longrightarrow a b \\
     & (6)  & C \longrightarrow a A \\
     & (7)  & D \longrightarrow b \\
     & (8)  & E \longrightarrow S a \\
     &   &\}
\end{eqnarray*}

 La aplicación del algoritmo \ref{algoritmo-vacuidad-gramatica-contexto-libre} consta de los siguientes pasos (figura \ref{fig-pasos-algoritmo-gramatica-vacia}):
\begin{description}
\item[\em Paso 0:] Inicialmente el conjunto $Viejo$ está vacío. Los símbolos no terminales $C$ y $D$ se incluyen en $Nuevo$ porque son los únicos que tienen alguna producción cuya parte derecha está compuesta sólo por símbolos terminales: producciones 5 y 7.
\item[\em Paso 1:] Como los conjuntos $Viejo$ y $Nuevo$ son diferentes y el símbolo inicial $S$ no pertenece a $Nuevo$, se asigna a $Viejo$ el valor de $Nuevo$ y se añaden a $Nuevo$ el símbolo $B$ porque la producción  número 4 tiene en la parte derecha a los símbolos $C$ y $D$ que pertenecen a $Viejo$.
\item[\em Paso 2:] Como la condición de salida del bucle no se cumple, se asigna a $Viejo$ el valor de $Nuevo$ y se incluye en $Nuevo$ el símbolo no terminal $A$ porque la parte derecha de la regla número 2 está compuesta por símbolos de $Viejo$, en concreto $B$ y $D$, y por el símbolo terminal $b$.
\item[\em Paso 3:] Puesto que la condición de salida todavía no se cumple, se asigna el valor de $Nuevo$ a $Viejo$ y se incluye en $Nuevo$ el símbolo inicial $S$ porque la regla número 1 tiene en la parte derecha a los símbolos $A$ y $B$ que pertenecen a $Viejo$ y al símbolo no terminal $a$.
\item[\em Paso final:] El bucle termina porque el símbolo inicial $S$ pertenece a $Nuevo$. El algoritmo concluye indicando que la gramática genera un lenguaje que no es vacío.  
\end{description}

\begin{figure}[htb]
\begin{center}
\begin{tabular}{||c|c|c||}
\hline 
    {\bf\em  Paso}  & {\bf\em Viejo}  & {\bf\em Nuevo}   \\
\hline 
\hline 
       0       &  $\emptyset$ & $\{C, D\}$  \\
\hline 
       1       &  $\{C,D\}$ & $\{B,C,D\}$ \\
\hline 
       2       &  $\{B,C,D\}$ & $\{A,B,C,D\}$ \\
\hline 
       3       &  $\{A,B,C,D\}$ & $\{S,A,B,C,D\}$ \\
\hline 
\end{tabular}
\end{center}
\caption{Pasos generados por el algoritmo que comprueba si una gramática genera o no un lenguaje vacío.}\label{fig-pasos-algoritmo-gramatica-vacia}
\end{figure}

\end{ejemplo}

\subsection{Símbolos útiles e inútiles}

\begin{definicion}\label{definicion-simbolo-util} 
 Se dice que un {\bf\em símbolo} de una gramática de contexto libre es {\bf\em útil} si aparece en una derivación de una cadena generada por la gramática, es decir, $$\exists S \Dflecha^* \alpha X \beta \Dflecha^* x \in V^*_T$$
\end{definicion}
  
 Las gramáticas pueden contener símbolos que no sean utilizados para generar ninguna palabra. Estos símbolos, por tanto, son inútiles y han de suprimirse. En las subsecciones siguientes se definen tales símbolos y se muestran los algoritmos que los eliminan.

\subsubsection{Símbolos generadores}

\begin{definicion}\label{definicion-simbolo-generador} 
 Se dice que un {\bf\em símbolo} $X$ de una gramática de contexto libre es {\bf\em generador} si existe una derivación de la gramática que, partiendo de dicho símbolo, genera una cadena (posiblemente vacía) de símbolos terminales, es decir,
\begin{equation}
 X \Dflecha^*_G x
\end{equation}
donde $X \in V = V_N \cup V_T \wedge x \in V_T^*$.
\end{definicion}

 Un símbolo no terminal $A$ es generador si la gramática genera un lenguaje no vacío cuando lo utiliza como símbolo inicial:
\begin{equation}
  L(G_A) = \{x | x \in V^* (A \Dflecha^+_G x) \} \neq \emptyset
\end{equation}

El siguiente teorema permite caracterizar los  símbolos que son generadores.
\begin{teorema}
 Un símbolo $X$ de una gramática de contexto libre $G = (V_N,V_T,P,S)$ es generador si y sólo si:
\begin{itemize}
\item $X$ es un símbolo terminal.
\item $X$ es un símbolo no terminal $A$ que verifica alguna de las siguientes condiciones:
	\begin{itemize}
	\item $\exists A \longrightarrow x \in P \wedge x \in V^*_T$
	\item $\exists A \longrightarrow \alpha \in P$ y $\alpha$ está compuesto sólo por símbolos gene\-ra\-dores.  
	\end{itemize}
\end{itemize}
\end{teorema}

\raisebox{0.75ex}{\fbox{}}
{\bf Demostración}

\fbox{$\Leftarrow$}

Todos los símbolos terminales de la gramática son generadores, porque se pueden derivar a sí mismos en cero pasos:
\begin{equation}
 V \Dflecha^0 V \in V_T
\end{equation}

 Si $X = A \in V_N$ entonces:
\begin{enumerate}
\item {\bf Base}: si $\exists A \longrightarrow x \in P \wedge x \in V^*_T$ entonces existe la derivación $A \Dflecha^+ x$ y, por tanto, $A$ es generador.
\item {\bf Inducción}: si $\exists A \longrightarrow \alpha \in P$ y $\alpha$ está compuesto sólo por símbolos gene\-ra\-dores entonces supóngase que $\alpha =  B_{i_1}  B_{i_2} \dots B_{i_k}$, donde $B_{i_j}$ es generador $\forall j \in \{1,2,\dots,k\}$. Si cada símbolo $B_{i_j}$ es generador entonces existe una derivación $B_{i_j} \Dflecha^+ x_{i_j}$ y $x_{i_j} \in V^*_T$. Utilizando estas derivaciones, se puede generar la siguiente derivación:
\begin{eqnarray*} 
 A & \Dflecha^1 & B_{i_1} B_{i_2} \dots B_{i_k} \\
   & \Dflecha^+ & x_{i_1} B_{i_2} \dots B_{i_k} \\
   & \Dflecha^+ & x_{i_1} x_{i_2} \dots B_{i_k} \\
   & \cdots & \\
   & \Dflecha^+ & x_{i_1} x_{i_2} \dots x_{i_k}  = x \in V^*_T
\end{eqnarray*} 
Por tanto, $A$ puede derivar una cadena de símbolos terminales $x$, lo cual implica que es generador.
\end{enumerate}

\fbox{$\Rightarrow$}

 Si $X$ es un símbolo generador entonces existe una cadena de símbolos terminales que puede ser derivada a partir de $X$: $X \Dflecha^*_G x \in V_T^*$. Supóngase que la derivación consta de $k$ pasos:
\begin{enumerate}
\item Si $k = 0$ entonces $X = x$ y $X$ es un símbolo terminal.
\item Si $k \geq 1$ entonces $X = A$, donde $A$ es un símbolo no terminal, y  existe una cadena $\alpha$ de símbolos gramaticales tal que $A \Dflecha^1 \alpha \Dflecha^{k-1} x$. El primer paso de la derivación implica la existencia de la producción $A \longrightarrow \alpha \in P$. Además, todos los símbolos de $\alpha$ han de ser generadores, porque si no lo fueran, no podrían generar la cadena de símbolos terminales $x$.
\end{enumerate}
\hfill\rule{1.5ex}{1.5ex}

Utilizando el teorema anterior, se ha desarrollado el siguiente algoritmo que permite eliminar los símbolos no terminales que no son ge\-ne\-radores.
\begin{algoritmo}\label{algoritmo-simbolos-no-generadores-gramatica-contexto-libre}{\bf\em Supresión de símbolos no generadores}
\begin{itemize}
\item Entrada: $G = (V_N,V_T,P,S)$ gramática de contexto libre.
\item Salida: $G' = (V'_N,V_T,P',S)$ gramática de contexto libre sin símbolos no generadores. 
\end{itemize}
\newcount\algocount
\begin{algorithm}
{\bf\em inicio}
\ $Viejo \leftarrow \emptyset$
\ $Nuevo \leftarrow \{A | A \in V_N \hspace{1ex} \wedge \hspace{1ex} \exists A \longrightarrow x \in P \hspace{1ex}  \wedge \hspace{1ex} x \in V^*_T\}$
\ {\bf\em mientras} $(Nuevo \neq Viejo)$ {\bf\em hacer} 
\ \ $Viejo \leftarrow Nuevo$
\ \ $Nuevo \leftarrow Viejo \cup \{A |A \in V_N \wedge \exists A \longrightarrow \alpha \in P \wedge  \alpha \in (Viejo \cup V_T)^*\}$
\ {\bf\em fin mientras}
\ $V'_N \longrightarrow Nuevo$
\ $P' \leftarrow \{A \longrightarrow \alpha | A \longrightarrow \alpha \in P \wedge A \in V'_N \wedge \alpha \in (V'_N \cup V_T)^*\}$
{\bf\em fin}
\end{algorithm}
\end{algoritmo}

 Las reglas de producción de la gramática $G'$ se obtienen a partir de las reglas de producción de la gramática $G$ que sólo tienen símbolos generadores.

\begin{ejemplo}\label{ejemplo-simbolos-inutiles-1}
 Sea $G = (V_N,V_T,P,S)$ una gramática de contexto libre donde $V_N = \{S,A,B,C,D,E,F\}$, $V_T = \{a,b,c\}$ y 
\begin{eqnarray*}
 P & = & \{ \\
   & (1) &  S \longrightarrow A B \\
   & (2) &  S \longrightarrow Ab \\
   & (3) &  A \longrightarrow aC \\
   & (4) &  B \longrightarrow bCa \\
   & (5) &  B \longrightarrow DbE \\
   & (6) &  C \longrightarrow b \\
   & (7) &  D \longrightarrow Fb \\
   & (8) &  E \longrightarrow ca \\
   & (9) &  F \longrightarrow aD \\
   &   & \}
\end{eqnarray*}

\begin{figure}[htb]
\begin{center}
\begin{tabular}{||c|c|c||}
\hline 
    {\bf\em  Paso}  & {\bf\em Viejo}  & {\bf\em Nuevo}   \\
\hline 
\hline 
       0       &  $\emptyset$ & $\{C, E\}$  \\
\hline 
       1       &  $\{C,E\}$ & $\{A,B,C,E\}$ \\
\hline 
       2       &  $\{A,B,C,E\}$ & $\{S,A,B,C,E\}$ \\
\hline 
       3       &  $\{S,A,B,C,E\}$ & $\{S,A,B,C,E\}$  \\
\hline 
\end{tabular}
\end{center}
\caption{Pasos del algoritmo que elimina los símbolos no generadores de una gramática de contexto libre.}\label{fig-pasos-algoritmo-elimina-no-generadores}
\end{figure}

Los pasos de aplicación del algoritmo \ref{algoritmo-simbolos-no-generadores-gramatica-contexto-libre} se describen a continuación (figura \ref{fig-pasos-algoritmo-elimina-no-generadores}):
\begin{description}
\item[\em Paso 0:] Inicialmente el conjunto $Viejo$ está vacío mientras que el conjunto $Nuevo$ está compuesto por los símbolos $C$ y $E$ ya que son los únicos símbolos no terminales que tienen alguna producción cuya parte izquierda consta sólo de símbolos terminales: producciones 6 y 8.
\item[\em Paso 1:] Como los conjuntos $Viejo$ y $Nuevo$ son diferentes, se asigna el valor de $Nuevo$ a $Viejo$ y se incluyen en nuevo a los símbolos $A$ y $B$ porque sus respectivas producciones 3 y 4 constan de símbolos de $Viejo$ o terminales.
\item[\em Paso 2:] Al no cumplirse la condición de salida del bucle, se asgina de el valor del conjunto $Nuevo$ a $Viejo$ y se incluen en $Nuevo$ el símbolo no terminal $S$ ya que  cualquiera de sus producciones (1 ó 2) cumple los requisitos de tener símbolos de $Viejo$ o terminales. 
\item[\em Paso 3:] Otra vez se asgina el valor de $Nuevo$ a $Viejo$. No se incluye ningún símbolo en el conjunto $Nuevo$ porque los símbolos $D$ y $F$ no tienen ninguna producción compuesta por símbolos de $Viejo$ o terminales.
\item[\em Paso final:] El bucle finaliza porque los conjuntos $Viejo$ y $Nuevo$ son iguales y se genera la siguiente gramática de contexto libre: $G' = (V'_N,V_T,P',S)$ donde $V'_N = Nuevo =  \{S,A,B,C,E\}$, $V_T = \{a,b,c\}$ y 
\begin{eqnarray*}
 P' & = & \{ \\
   &   &  S \longrightarrow A B \hspace{1ex} | \hspace{1ex} A b \\
   &   &  A \longrightarrow a C \\
   &   &  B \longrightarrow b C a \\
   &   &  C \longrightarrow b \\
   &   &  E \longrightarrow c a \\
   &   & \}
\end{eqnarray*}
\end{description}

 Se puede observar cómo se han suprimido los símbolos $D$ y $F$ porque no pueden generar ninguna cadena de símbolos terminales. 

\end{ejemplo}

\subsubsection{Símbolos accesibles}

\begin{definicion} 
 Se dice que un {\bf\em símbolo} $X$ de una gramática de contexto libre es {\bf\em accesible} si existe una derivación inicial que permite generar una cadena que contiene a $X$, es decir,
\begin{equation}
 \exists S \Dflecha^+ \alpha X \beta
\end{equation}
donde $X \in V = V_N \cup V_T \wedge  \alpha, \beta \in V^* = (V_N \cup V_T)^*$.
\end{definicion}

\begin{teorema}
 Un símbolo $X$ de una gramática de contexto libre $G = (V_N,V_T,P,S)$ es accesible si y sólo si verifica alguna de las siguientes condiciones:
\begin{itemize}
\item $\exists S \longrightarrow \alpha X \beta \in P \wedge \alpha, \beta \in V^* = (V_N \cup V_T)^*$
\item $\exists A \longrightarrow \alpha' X \beta' \in P \wedge \alpha', \beta' \in V^* = (V_N \cup V_T)^*$ y $A$ es un símbolo accesible.
\end{itemize}
\end{teorema}

\raisebox{0.75ex}{\fbox{}}
{\bf Demostración}

\fbox{$\Rightarrow$}

 Si un símbolo $X$ es accesible entonces $\exists S \Dflecha^+ \alpha X \beta$.  Si se analiza el número de pasos de la derivación, se tiene que: 
\begin{itemize}
\item si la derivación consta de un único paso entonces $\exists S \longrightarrow \alpha X \beta \in P$
\item si la derivación consta  más de un paso entonces  existe un símbolo accesible $A$ y una producción $A \longrightarrow \alpha' X \beta' \in P \wedge \alpha', \beta' \in V^* = (V_N \cup V_T)^*$ tal que
$$\exists S \Dflecha^* \alpha'' A \beta'' \Dflecha \alpha'' \alpha' X \beta' \beta'' = \alpha  X \beta$$
\end{itemize}

\fbox{$\Leftarrow$}

\begin{enumerate}
\item {\bf Base}: si $\exists S \longrightarrow \alpha X \beta \in P \wedge \alpha, \beta \in V^* = (V_N \cup V_T)^*$ entonces existe la derivación  $ S \Dflecha \alpha X \beta \in P \wedge \alpha, \beta \in V^* = (V_N \cup V_T)^*$ y, por tanto, $X$ es accesible. 
\item {\bf Inducción}: si $\exists A \longrightarrow \alpha' X \beta' \in P \wedge \alpha', \beta' \in V^* = (V_N \cup V_T)^*$ y $A$ es un símbolo accesible entonces existe una derivación $S \Dflecha^* \alpha'' A \beta''$, donde $\alpha'', \beta'' \in V^* = (V_N \cup V_T)^*$. Utilizando la derivación y la producción se puede generar la siguiente derivación:
\begin{eqnarray*} 
 S & \Dflecha^* & \alpha'' A \beta'' \\ 
   & \Dflecha^1 & \alpha'' \alpha' X \beta' \beta'' = \alpha  X \beta 
\end{eqnarray*} 
Por tanto, existe una derivación del símbolo inicial que genera una cadena que contiene a $X$, lo cual implica que $X$ es accesible.
\end{enumerate}
\hfill\rule{1.5ex}{1.5ex}

 El siguiente algoritmo se basa en el anterior para suprimir los símbolos de la gramática que no son accesibles.

\begin{algoritmo}\label{algoritmo-supresion-no-accesibles-gramatica-contexto-libre}{\bf\em Supresión de símbolos no accesibles}
\begin{itemize}
\item Entrada: $G' = (V'_N,V_T,P',S)$ gramática de contexto libre sin símbolos no generadores.
\item Salida: $G'' = (V''_N,V'_T,P'',S)$ gramática de contexto libre sin símbolos no accesibles. 
\end{itemize}
\newcount\algocount
\begin{algorithm}
{\bf\em inicio}
\ $Viejo \leftarrow \{S\}$
\ $Nuevo \leftarrow \{X | X \in (V'_N \cup V_T) \wedge \exists S \longrightarrow \alpha X \beta \in P' \wedge \alpha, \beta \in (V'_N \cup V_T)^*\}$
\ {\bf\em mientras} $(Nuevo \neq Viejo)$ {\bf\em hacer} 
\ \ $Viejo \leftarrow Nuevo$
\ \ $Nuevo \leftarrow Viejo \cup \{X |\exists A \longrightarrow \alpha X \beta \in P' \hspace{1ex} \wedge \hspace{1ex} A \in Viejo \hspace{1ex} \wedge $
\ \ \ \ \ \ \ $X \in (V'_N \cup V_T) \hspace{1ex} \wedge \hspace{1ex} \alpha, \beta \in (V'_N \cup V_T)^*\}$
\ {\bf\em fin mientras}
\ $V''_N \longrightarrow Nuevo \cap V'_N$
\ $V'_T \longrightarrow Nuevo \cap V_T$
\ $P'' \leftarrow \{A \longrightarrow \alpha | A \longrightarrow \alpha \in P' \wedge A \in V''_N \wedge \alpha \in (V''_N \cup V'_T)^*\}$
{\bf\em fin}
\end{algorithm}
\end{algoritmo}

 Las reglas de producción de la gramática $G''$ se obtienen a partir de las reglas de producción de la gramática $G'$ que sólo tienen símbolos accesibles.

\begin{ejemplo}
 Sea $G' = (V'_N,V_T,P',S)$ la gramática sin símbolos no generadores obtenida en el ejemplo \ref{ejemplo-simbolos-inutiles-1}

La aplicación del algoritmo \ref{algoritmo-supresion-no-accesibles-gramatica-contexto-libre} consta de los siguientes pasos (figura \ref{fig-pasos-algoritmo-elimina-no-accesibles}):
\begin{description}
\item[\em Paso 0:] Inicialmente, el conjunto $Viejo$ está compuesto sólo por el símbolo inicial $S$, mientras que el conjunto $Nuevo$ también contiene a $S$ y los símbolos que aparecen en las partes derechas de las producciones de $S$, es decir, $A$, $B$ y $b$.
\item[\em Paso 1:] Como los conjuntos $Viejo$ y $Nuevo$ son diferentes, se asigna el valor de $Nuevo$ a $Viejo$ y se incluyen en $Nuevo$ los símbolos que aparecen en las partes derechas de las producciones de $A$ y $B$ y que aún no estaban en $Nuevo$: $C$ y $a$.   
\item[\em Paso 2:] Todavía no se cumple la condición de salida porque los conjuntos $Viejo$ y $Nuevo$ son diferentes. Tras asignar a $Viejo$ el valor de $Nuevo$, se comprueba que no se pueden incluir nuevos símbolos en el conjunto $Nuevo$.
\item[\em Paso final:] El bucle termina y se genera la gramática de contexto libre $G'' = (V'_N,V_T,P',S)$ donde $V''_N = Nuevo \cap V'_N =  \{S,A,B,C\}$, $V'_T = Nuevo \cap V_T = \{a,b\}$ y 
\begin{eqnarray*}
 P'' & = & \{ \\
   &   &  S \longrightarrow A B \hspace{1ex} | \hspace{1ex} A b \\
   &   &  A  \longrightarrow aC \\
   &   &  B  \longrightarrow bCa \\
   &   &  C  \longrightarrow b \\
   &   & \}
\end{eqnarray*}
 Se han suprimido los símbolos $E$ y $c$ porque no son accesibles desde el símbolo inicial de la gramática.
\end{description}

\begin{figure}[htb]
\begin{center}
\begin{tabular}{||c|c|c||}
\hline 
    {\bf\em  Paso}  & {\bf\em Viejo}  & {\bf\em Nuevo}   \\
\hline   
\hline  
       0       &  $\{S\}$ & $\{S,A,B,b\}$  \\
\hline 
       1       &  $\{S,A,B,b\}$ & $\{S,A,B,C,a,b\}$ \\
\hline 
       2       &  $\{S,A,B,C,a,b\}$ & $\{S,A,B,C,a,b\}$  \\
\hline 
\end{tabular}
\end{center}
\caption{Pasos del algoritmo que elimina los símbolos no accesibles de una gramática de contexto libre.}\label{fig-pasos-algoritmo-elimina-no-accesibles}
\end{figure}

\end{ejemplo}


\subsubsection{Supresión de símbolos inútiles}

\begin{teorema}
 Toda gramática de contexto libre que genere un lenguaje no vacío es equivalente a una gramática de contexto libre sin símbolos inútiles.
\end{teorema}

\raisebox{0.75ex}{\fbox{}}
{\bf Demostración}
 
 Sea $G = (V_N,V_T,P,S)$ una gramática de contexto libre que genere un lenguaje $L(G) \neq \emptyset$. Si $G$ no tiene símbolos inútiles entonces no hay nada que demostrar. Si $G$ posee símbolos inútiles, sea $G''= (V''_N,V'_T,P'',S)$ la gramática de contexto libre que se crea después de aplicar las dos siguientes transformaciones:
\begin{enumerate}
\item $G' = (V'_N,V_T,P',S)$ es la gramática que se obtiene al aplicar el algoritmo \ref{algoritmo-simbolos-no-generadores-gramatica-contexto-libre} que elimina los símbolos que no son generadores. En particular $S \in V'_N$ porque la gramática $G$ genera un lenguaje no vacío. 
\item $G'' = (V''_N,V'_T,P'',S)$ es la gramática que se obtiene al aplicar el algoritmo \ref{algoritmo-supresion-no-accesibles-gramatica-contexto-libre} que elimina los símbolos que no son accesibles. 
\end{enumerate}

 Una vez obtenida la gramática $G''$ se ha de comprobar que:
\begin{enumerate}
\item Todos sus símbolos son útiles. 
\item Es equivalente a la gramática orignal $G$.
\end{enumerate}

Si $X$ es un símbolo de $G''$ entonces se ha obtenido a partir de $G'$, lo que implica que $X$ es un símbolo generador. Por tanto, $\exists X \Dflecha^* x \in V_T^*$ donde todos los símbolos que aparecen en la derivación son generadores. 

 Además, como $X$ pertenece a $G''$, también es accesible, es decir, $\exists S \Dflecha^* \alpha X \beta$, donde $\alpha$ y $\beta$ son cadenas compuestas por símbolos accesibles y generadores. En particular, supondremos que $\alpha$ y $\beta$ generan, respectivamente, las cadenas $w$ e $y$, es decir, $\alpha \Dflecha^* w$ y $\beta \Dflecha^* y$.

Utilizando estas derivaciones, se puede crear la derivación:
\begin{eqnarray*}
 S & \Dflecha^* & \alpha X \beta \\
   & \Dflecha^* & w X \beta \\
   & \Dflecha^* & w x \beta \\
   & \Dflecha^* & w x y \in V'_T
\end{eqnarray*}
Esta derivación manifiesta que el símbolo $X$ es útil para la gramática. Puesto que $X$ es un símbolo arbitrario, todos los símbolos de $G''$ son útiles.

 Para demostrar que las gramáticas $G$ y $G''$ son equivalentes, se ha de comprobar que $L(G) = L(G'')$:

\fbox{$\Leftarrow$}

  $L(G'') \subseteq L(G)$ porque todos las reglas de producción de $G''$ también están en $G$.

\fbox{$\Rightarrow$}

  Para comprobar que $L(G) \subseteq L(G'')$, sea $x \in L(G)$, es decir, $\exists S \Dflecha^+ x$. Esta derivación tiene que estar compuesta por símbolos accesibles y generadores, los cuales están incluidos en la gramática $G''$. Por tanto, $x \in L(G'')$. 
\hfill\rule{1.5ex}{1.5ex}

 Para obtener una gramática sin símbolos inútiles, se ha de aplicar primero el algoritmo que elimina los símbolos no generadores y después el algoritmo que elimina los símbolos no accesibles. Si se invierte el orden, no se garantiza que se hayan eliminado todos los símbolos no accesibles. Este problema se muestra en el siguiente ejemplo.

\begin{ejemplo}
 Considérese de nuevo la gramática del ejemplo \ref{ejemplo-simbolos-inutiles-1} . 

\begin{figure}[htb]
\begin{center}
\begin{tabular}{||c|c|c||}
\hline 
    {\bf\em  Paso}  & {\bf\em Viejo}  & {\bf\em Nuevo}   \\
\hline   
\hline  
       0       &  $\{S\}$ & $\{S,A,B,b\}$  \\
\hline 
       1       &  $\{S,A,B,b\}$ & $\{S,A,B,C,D,E,a,b\}$ \\
\hline 
       2       &  $\{S,A,B,C,D,E,a,b\}$ & $\{S,A,B,C,D,E,F,a,b,c\}$  \\
\hline 
       3       &  $\{S,A,B,C,D,E,F,a,b\}$ & $\{S,A,B,C,D,E,F,a,b,c\}$  \\
\hline 
\end{tabular}
\end{center}
\caption{Pasos del algoritmo que elimina los símbolos no accesibles de una gramática de contexto libre.}\label{fig-pasos-algoritmo-elimina-no-accesibles-2}
\end{figure}

Si se aplica primero el algoritmo \ref{algoritmo-supresion-no-accesibles-gramatica-contexto-libre} que elimina los símbolos no accesibles, se puede observar en la figura \ref{fig-pasos-algoritmo-elimina-no-accesibles-2} que no se suprime ningún símbolo. 

\begin{figure}[htb]
\begin{center}
\begin{tabular}{||c|c|c||}
\hline 
    {\bf\em  Paso}  & {\bf\em Viejo}  & {\bf\em Nuevo}   \\
\hline 
\hline 
       0       &  $\emptyset$ & $\{C, E\}$  \\
\hline 
       1       &  $\{C,E\}$ & $\{A,B,C,E\}$ \\
\hline 
       2       &  $\{A,B,C,E\}$ & $\{S,A,B,C,E\}$ \\
\hline 
       3       &  $\{S,A,B,C,E\}$ & $\{S,A,B,C,E\}$  \\
\hline 
\end{tabular}
\end{center}
\caption{Pasos del algoritmo que elimina los símbolos no generadores de una gramática de contexto libre.}\label{fig-pasos-algoritmo-elimina-no-generadores-2}
\end{figure}

Si, a continuación, se aplica el algoritmo \ref{algoritmo-simbolos-no-generadores-gramatica-contexto-libre} que elimina los símbolos no generadores (figura \ref{fig-pasos-algoritmo-elimina-no-generadores-2}), el conjunto de producciones resultante, que se muestra a continuación, contiene los símbolos $E$ y $c$ que no son accesibles.

\begin{eqnarray*}
 P & = & \{ \\
   & (1) &  S \longrightarrow A B \\
   & (2) &  S \longrightarrow Ab \\
   & (3) &  A \longrightarrow aC \\
   & (4) &  B \longrightarrow bCa \\
   & (6) &  C \longrightarrow b \\
   & (8) &  E \longrightarrow ca \\
   &   & \}
\end{eqnarray*}
\end{ejemplo}

En resumen, para eliminar todos los símbolos inútiles de una gramática, se ha de aplicar primero el algoritmo \ref{algoritmo-simbolos-no-generadores-gramatica-contexto-libre} que elimina los símbolos no generadores y, a continuación, el algoritmo \ref{algoritmo-supresion-no-accesibles-gramatica-contexto-libre} que elimina los símbolos no accesibles.

\subsection{Gramática sin ciclos y gramática propia}

 En la sección anterior se han descrito los algoritmos que permiten eliminar los símbolos inútiles. A continuación se van a describir cómo se pueden eliminar también reglas producción superfluas. Estas operaciones de {\em limpieza} de la gramática facilitan que las derivaciones de las palabras sean más eficientes. En particular, se evita la presencia de ciclos en las derivaciones.

\begin{definicion}
Se dice que una {\bf\em gramática es sin ciclos} si no tiene derivaciones de la forma $A \Dflecha^+ A$.
\end{definicion}
 
 Los ciclos dificultan el proceso de generación de las palabras y por ello deben evitarse. La aparición de ciclos se debe a la presencia producciones unitarias o producciones $\epsilon$.  

\begin{ejemplo}
 Supóngase que una gramática contiene las siguientes producciones:
\begin{eqnarray*}
 P  & = & \{ \\
    &   & \cdots \\
    &   &  A  \longrightarrow B C \\
    &   &  B  \longrightarrow \epsilon \\
    &   &  C  \longrightarrow A \\
    &   & \cdots \\
    &   & \}
\end{eqnarray*}
 Esta gramática permite generar el siguiente ciclo:
\begin{eqnarray*}
  A \Dflecha B C \Dflecha C \Dflecha A
\end{eqnarray*}
\end{ejemplo}
 
 Obivamente, una gramática sin $\epsilon$ (definición \ref{definicion-gramatica-sin-epsilon} ) que no tenga reglas de producción unitarias no puede generar ciclos.

\begin{definicion}\label{definicion-gramatica-propia}
 Se dice que una {\bf gramática es propia} si es una gramática sin ciclos, sin producciones\footnote{Recuérdese la definición \ref{definicion-gramatica-sin-epsilon}.} $\epsilon$ ni símbolos inútiles.
\end{definicion}


\subsubsection{Supresión de producciones $\epsilon$}\label{sec-supresion-reglas-epsilon}

\begin{definicion}\label{definicion-gramatica-sin-epsilon} 
 Se dice que una {\bf\em gramática} de contexto libre es {\bf\em sin $\epsilon$} si cumple alguna de las siguientes condiciones:
\begin{enumerate}
\item No tiene ninguna producción $\epsilon$.
\item Sólo hay una producción $\epsilon$ y está asociada al símbolo inicial ($S \longrightarrow \epsilon)$ y además $S$ no aparece en la parte derecha de ninguna producción de la gramática.
\end{enumerate}
\end{definicion} 

 Toda gramática de contexto libre se pueden transformar en otra ``gramática sin $\epsilon$''. Para ello es necesario definir previamente el concepto de símbolo anulable.

\begin{definicion} 
 Un {\bf\em símbolo no terminal} $A$ es {\bf\em anulable} si $ A \Dflecha^+ \epsilon$.
\end{definicion} 

\begin{teorema}
 Un símbolo no terminal $A$ de una gramática de contexto libre $G = (V_N,V_T,P,S)$ es anulable si verifica alguna de las siguientes condiciones:
\begin{itemize}
\item $\exists A \longrightarrow \epsilon \in P$
\item $\exists A \longrightarrow \alpha \in P$ y $\alpha$ está compuesto sólo por símbolos anulables.  
\end{itemize}
\end{teorema}

\raisebox{0.75ex}{\fbox{}}
{\bf Demostración}

\begin{enumerate}
\item {\bf Base}: si $\exists A \longrightarrow \epsilon \in P$ entonces existe la derivación $A \Dflecha^+ \epsilon$ y, por tanto, $A$ es anulable.
\item {\bf Inducción}: si $\exists A \longrightarrow \alpha \in P$ y $\alpha$ está compuesto sólo por símbolos anulables entonces supóngase que $\alpha =  B_{i_1}  B_{i_2} \dots B_{i_k}$, donde $B_{i_j}$ es anulable para todo $j \in \{1,2,\dots,k\}$. 

  Si cada símbolo $B_{i_j}$ es anulable entonces existe una derivación $B_{i_j} \Dflecha^+ \epsilon$. Utilizando estas derivaciones, se puede generar la siguiente derivación:
\begin{eqnarray*} 
 A & \Dflecha^1 & B_{i_1} B_{i_2} B_{i_3} \dots B_{i_k} \\
   & \Dflecha^+ &  \epsilon B_{i_2} B_{i_3} \dots B_{i_k} = B_{i_2} B_{i_3} \dots B_{i_k} \\
   & \Dflecha^+ &  \epsilon B_{i_3} \dots B_{i_1} = B_{i_3} \dots B_{i_1} \\
   & \cdots & \\
   & \Dflecha^+ & \epsilon  B_{i_k} =  B_{i_k} \\
   & \Dflecha^+ &  \epsilon 
\end{eqnarray*} 
Por tanto, $A$ puede derivar la palabra vacía, lo cual implica que es anulable.
\end{enumerate}
\hfill\rule{1.5ex}{1.5ex}
 
El siguiente algoritmo desarrolla el método descrito en este teorema para determinar los símbolos anulables de una gramática. 
\begin{algoritmo}\label{algoritmo-simbolos-anulables}{\bf\em Obtención de los símbolos anulables}
\begin{itemize}
\item Entrada: $G = (V_N,V_T,P,S)$ gramática de contexto libre sin símbolos inútiles.
\item Salida: Anulables, conjunto de símbolos anulables.
\end{itemize}
\newcount\algocount
\begin{algorithm}
{\bf\em inicio}
\ $Viejo \leftarrow \emptyset$
\ $Nuevo \leftarrow \{A | A \in V_N \hspace{1ex} \wedge \hspace{1ex} \exists A \longrightarrow \epsilon \in P\}$
\ {\bf\em mientras} $(Nuevo \neq Viejo)$ {\bf\em hacer} 
\ \ $Viejo \leftarrow Nuevo$
\ \ $Nuevo \leftarrow Viejo \cup \{A | A \in V_N \hspace{1ex} \wedge \hspace{1ex} \exists A \longrightarrow \alpha \in P \hspace{1ex} \wedge \hspace{1ex} \alpha \in Viejo^*\}$
\ {\bf\em fin mientras}
\ $Anulables \longrightarrow Nuevo$
{\bf\em fin}
\end{algorithm}
\end{algoritmo}

\begin{ejemplo}\label{ejemplo-simbolos-anulables}
 Sea $G = (V_N,V_T,P,S)$ una gramática de contexto libre donde $V_N = \{S,A,B,C,D,E\}$, $V_T = \{a,b\}$ y 
\begin{eqnarray*}
 P & = & \{ \\
   & (1) &  S \longrightarrow A D \\
   & (2) &  S \longrightarrow B \\
   & (3) &  A \longrightarrow C D E \\
   & (4) &  B \longrightarrow C E \\
   & (5) &  C \longrightarrow S \\
   & (6) &  C \longrightarrow a \\
   & (7) &  C \longrightarrow \epsilon \\
   & (8) &  D \longrightarrow A \\
   & (9) &  D \longrightarrow b \\
   & (10) &  E \longrightarrow S \\
   & (11) &  E \longrightarrow a \\
   & (12) &  E \longrightarrow \epsilon \\
   &   & \}
\end{eqnarray*}

 Los pasos para obtener el conjunto de símbolos anulables de esta gramática (figura \ref{fig-pasos-algoritmo-anulable}) se muestran a continuación: 
\begin{description}
\item[\em Paso 0:] Inicialmente, el conjunto $Viejo$ está vacío, mientras que el conjunto $Nuevo$ contiene a $C$ y $E$ porque poseen dos producciones $\epsilon$.
\item[\em Paso 1:] Como los conjuntos $Viejo$ y $Nuevo$ son diferentes, se asigna el valor de $Nuevo$ a $Viejo$ y se incluyen en $Nuevo$ el símbolo $B$ porque contiene una regla compuesta sólo por los símbolos anulabes $C$ y $E$.
\item[\em Paso 2:] Todavía no se cumple la condición de salida porque los conjuntos $Viejo$ y $Nuevo$ son diferentes. Tras asignar a $Viejo$ el valor de $Nuevo$, se incluye en $Nuevo$ el símbolo $S$ porque contiene una regla compuesta sólo por el símbolo anulabe $B$.
\item[\em Paso 3:] Se asigna el valor de $Nuevo$ a $Viejo$ y no se incluye ningún símbolo más en $Nuevo$.
\item[\em Paso final:] El bucle termina porque los conjuntos $Nuevo$ y $Viejo$ son iguales. 
\end{description}


\begin{figure}[htb]
\begin{center}
\begin{tabular}{||c|c|c||}
\hline 
    {\bf\em  Paso}  & {\bf\em Viejo}  & {\bf\em Nuevo}   \\
\hline 
\hline 
       0       &  $\emptyset$ & $\{C,E\}$  \\
\hline 
       1       &  $\{C,E\}$ & $\{B,C,E\}$ \\
\hline 
       2       &  $\{B,C,E\}$ & $\{S,B,C,E\}$ \\
\hline 
       3       &  $\{S,B,C,E\}$ & $\{S,B,C,E\}$  \\
\hline 
\end{tabular}
\end{center}
\caption{Pasos de aplicación del algoritmo \ref{algoritmo-simbolos-anulables} que obtiene los símbolos anulables.}\label{fig-pasos-algoritmo-anulable}
\end{figure}
 
\end{ejemplo}

 Una vez obtenido el conjunto de símbolos anulables, el algoritmo para transfomar una gramática en otra gramática sin $\epsilon$ equivalente es el siguiente:
\begin{algoritmo}\label{algoritmo-gramatica-sin-epsilon}{\bf\em Gramática sin $\epsilon$}
\begin{itemize}
\item Entrada: $G = (V_N,V_T,P,S)$ gramática de contexto libre sin símbolos inútiles y el conjunto de símbolos anulables de $G$.
\item Salida: $G' = (V'_N,V_T,P',S')$ gramática sin $\epsilon$.
\end{itemize}

\newcount\algocount
\begin{algorithm}
{\bf\em inicio}
\ $P' \leftarrow \{A \longrightarrow \alpha| A \longrightarrow \alpha \in P \hspace{1ex} \wedge \hspace{1ex} \alpha \neq \epsilon \hspace{1ex} \wedge$
\ \ \ \ \ $\alpha$ no contiene ningún símbolo anulable\} 
\ {\bf\em para} $(A \longrightarrow \alpha \in P) \wedge (\alpha$ contiene símbolos anulables$)$ {\bf\em hacer} 
\ \ {\bf\em si}  $\alpha = \alpha_0 B_1 \alpha_1 \dots B_k \alpha_k$ 
\ \ \ $\wedge \forall i$ $(B_i \in Anulables)$
\ \ \ $\wedge \forall j$ $(\alpha_j$ no contiene ningún símbolo anulable$)$ 
\ \ \ {\bf\em entonces} 
\ \ \ \ $P' \leftarrow P' \cup \{A \longrightarrow \alpha_0 X_1 \alpha_1 \dots X_k \alpha_k|$
\ \ \ \ \ \ $\forall i$ $(X_i = B_i \vee X_i = \epsilon) \hspace{1ex} \wedge \hspace{1ex} \alpha_0 X_1 \alpha_1 \dots X_k \alpha_k \neq \epsilon\}$ 
\ \ {\bf\em fin si} 
\ {\bf\em fin para}
\ {\bf\em si} $S \in Anulables$
\ \ {\bf\em entonces} 
\ \ \ $V'_N = V_N \cup \{S'\}$
\ \ \ $P' \leftarrow P' \cup \{S' \longrightarrow  \epsilon, S' \longrightarrow S\}$
\ {\bf\em fin si}
{\bf\em fin}
\end{algorithm}
\end{algoritmo}

\begin{ejemplo}\label{ejemplo-reglas-epsilon}
 Sea $G = (V_N,V_T,P,S)$ la gramática de contexto libre del ejemplo \ref{ejemplo-simbolos-anulables} cuyo conjunto de símbolos anulables es $\{S,B,C,E\}$. La gramática sin $\epsilon$ equivalente es $G' = (V'_N,V_T,P',S')$ donde las reglas de producción de $P'$ se obtienen a partir de las reglas de producción de $P$:
\begin{description}
\item[\em Paso 0:]
Se incluyen en $P'$ las reglas que no contienen en su parte derecha ningún símbolo anulables y que no son producciones $\epsilon$:  
\begin{eqnarray*}
 P' & = & \{ \\
   & (1) &  S \longrightarrow A D \\
   & (6) &  C \longrightarrow a \\
   & (8) &  D \longrightarrow A \\
   & (9) &  D \longrightarrow b \\
   & (11) &  E \longrightarrow a \\
   &   & \}
\end{eqnarray*}
\item[\em Paso 1:] La regla  $S \longrightarrow B$ contiene el símbolo anulable $B$ lo que provoca la generación de las dos reglas siguientes:
\begin{eqnarray*}
     S & \longrightarrow & B \\
     S & \longrightarrow & \epsilon 
\end{eqnarray*}
 Sólo se añade a $P'$ la primera regla porque la otra es una producción $\epsilon$.
\item[\em Paso 2:] La regla  $A \longrightarrow C D E$ contiene los símbolos anulable $C$ y $E$ lo que provoca la generación de las cuatro reglas siguientes:
\begin{eqnarray*}
    A & \longrightarrow & C D E \\
    A & \longrightarrow & D E \\
    A & \longrightarrow & C D \\
    A & \longrightarrow & D 
\end{eqnarray*}
que se añaden a $P'$ porque ninguna es una producción $\epsilon$.
\item[\em Paso 3:] La regla  $B \longrightarrow C E$ contiene los símbolos anulable $C$ y $E$ lo que provoca la generación de las cuatro reglas siguientes:
\begin{eqnarray*}
    B & \longrightarrow & C  E \\
    B & \longrightarrow & E \\
    B & \longrightarrow & C  \\
    B & \longrightarrow & \epsilon 
\end{eqnarray*}
Sólo se añaden a $P'$ las tres primeras reglas porque la otra es una producción $\epsilon$.
\item[\em Paso 4:] La regla  $C \longrightarrow S$ contiene el símbolo anulable $S$  lo que provoca la generación de las dos reglas siguientes:
\begin{eqnarray*}
    C & \longrightarrow & S \\
    C & \longrightarrow & \epsilon 
\end{eqnarray*}
 Sólo se añade a $P'$ la primera regla porque la otra es una producción $\epsilon$.
\item[\em Paso 5:] La regla  $E \longrightarrow S$ contiene el símbolo anulable $S$  lo que provoca la generación de las dos reglas siguientes:
\begin{eqnarray*}
    E & \longrightarrow & S \\
    E & \longrightarrow & \epsilon 
\end{eqnarray*}
 Sólo se añade a $P'$ la primera regla porque la otra es una producción $\epsilon$.
\item[\em Paso final:] Como el símbolo $S$ es anulable, se añaden a la gramática las siguientes producciones:
\begin{eqnarray*}
    S' & \longrightarrow & \epsilon \\
    S' & \longrightarrow & S 
\end{eqnarray*}
\end{description}

 Se han suprimido las producciones $\epsilon$ 
\begin{eqnarray*}
   & (7) & C \longrightarrow \epsilon \\
   & (12) &  E \longrightarrow \epsilon \\
\end{eqnarray*}

 El conjunto final de reglas de producción es: 
\begin{eqnarray*}
 P'  & = & \{ \\
 & &  S'  \longrightarrow  \epsilon \hspace{1ex} | \hspace{1ex} S \\
 & &  S \longrightarrow A D \hspace{1ex} | \hspace{1ex} B \\
 & &  A \longrightarrow C D E \hspace{1ex} | \hspace{1ex} D E \hspace{1ex} | \hspace{1ex} C D \hspace{1ex} | \hspace{1ex} D \\ 
 & &  B \longrightarrow C  E  \hspace{1ex} | \hspace{1ex}  E \hspace{1ex} | \hspace{1ex} C \\
 & &  C \longrightarrow S \hspace{1ex} | \hspace{1ex} a \\
 & &  D \longrightarrow A \hspace{1ex} | \hspace{1ex} b \\
 & &  E \longrightarrow S \hspace{1ex} | \hspace{1ex} a \\
 & & \}
\end{eqnarray*}

\end{ejemplo}

\subsubsection{Supresión de reglas unitarias}

\begin{definicion}
  Una {\bf\em regla} de producción es {\bf\em unitaria} si es de la forma 
\begin{equation}
  A \longrightarrow B
\end{equation}
donde $A, B \in V_N$.
\end{definicion}
 
 Se hace notar que los dos símbolos de una regla unitaria han de ser símbolos no terminales. Por tanto, si $A \in V_N$ y $b \in V_T$ entonces la siguiente regla no es unitaria:
\begin{equation}
  A \longrightarrow b
\end{equation}
porque el símbolo $b$ es un terminal. 

  La presencia de reglas unitarias en una gramática puede provocar que sus dericvaciones sean más ineficientes, ya que se podrían generar derivaciones inmediatas superfluas en las que sólo se cambia el nombre de un símbolo no terminal. Considérese el siguiente ejemplo.

\begin{ejemplo} La gramática del ejemplo \ref{ejemplo-gramatica-expresiones-no-ambigua} permite generar expresiones arit\-mé\-ticas como la que se muestra a continuación:
\begin{eqnarray*}
  S  & \Dflecha_1 & \mbox{\bf\em identificador } = \hspace{1ex} E \\
     & \Dflecha_2 & \mbox{\bf\em identificador } = \hspace{1ex} E \hspace{1ex} + \hspace{1ex} T \\
     & \Dflecha_3 & \mbox{\bf\em identificador } = \hspace{1ex} T \hspace{1ex} + \hspace{1ex} T \\
     & \Dflecha_5 & \mbox{\bf\em identificador } = \hspace{1ex} F \hspace{1ex} + \hspace{1ex} T \\
     & \Dflecha_7 & \mbox{\bf\em identificador } = \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} + \hspace{1ex} T \\
     & \Dflecha_4 & \mbox{\bf\em identificador } = \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} + \hspace{1ex} F \\
     & \Dflecha_7 & \mbox{\bf\em identificador } = \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} + \hspace{1ex} \mbox{\bf\em identificador} 
\end{eqnarray*}

\begin{figure}[htb]
\centerline{
\begin{tabular}{cc}
\psfig{file=figuras/gramaticas-contexto-libre/arbol-derivacion-reglas-unitarias.pdf,width=6cm} & 
\psfig{file=figuras/gramaticas-contexto-libre/arbol-derivacion-reglas-unitarias-2.pdf,width=6cm}  \\  \\
 (a) & (b)
\end{tabular}
}
\caption{Eliminación de reglas unitarias: (a) árbol de derivación de una gramática con reglas unitarias y (b) árbol de derivación de una gramática equivalente sin reglas unitarias.}\label{fig-arbol-derivacion-reglas-unitarias}
\end{figure}

  La figura \ref{fig-arbol-derivacion-reglas-unitarias}(a) muestra el árbol sintáctico asociado a esta derivación. Como se puede observar, las reglas unitarias provocan que el árbol tenga ramas ``alargadas'' en las que cada ``nodo'' sólo tiene un ``hijo''.  Estas ramas pueden ser ``acortadas'' si se eliminan las derivaciones inmediatas asociadas a las reglas unitarias (figura \ref{fig-arbol-derivacion-reglas-unitarias}(b)). Por ejemplo, las derivaciones inmediatas de los pasos 3, 4 y 5 
\begin{eqnarray*}
  E  & \Dflecha_3 & T  \\
     & \Dflecha_5 & F \\
     & \Dflecha_7 & \mbox{\bf\em identificador}
\end{eqnarray*}
se podrían sustituir por la siguiente derivación inmediata
\begin{eqnarray*}
     E & \Dflecha &   \mbox{\bf\em identificador }
\end{eqnarray*}
 donde $E  \longrightarrow   \mbox{\bf\em identificador}$ sería una nueva regla de producción de la gramática.
\end{ejemplo}
 
 Para eliminar las reglas unitarias de una gramática, es necesario calcular previamente los siguientes conjuntos

\begin{definicion}
  Si $G$ es una gramática sin $\epsilon$ (definición \ref{definicion-gramatica-sin-epsilon}) y $A \in V_N$, el conjunto de símbolos no terminales accesibles desde $A$ por medio de reglas unitarias se define como:
\begin{equation} 
  N_A = \{B| B \in V_N \wedge  A \Dflecha^* B\}
\end{equation} 
\end{definicion}

\begin{teorema}
 Un símbolo no terminal $B$ de una gramática de contexto libre $G = (V_N,V_T,P,S)$ es accesible desde otro símbolo no terminal $A$ mediante reglas unitarias si y sólo si verifica alguna de las siguientes condiciones:
\begin{itemize}
\item $B = A$
\item $\exists A \longrightarrow B \in P$
\item $\exists A \Dflecha^* C$  y $ C \longrightarrow B \in P$.  
\end{itemize}
\end{teorema}


Para hacer este proceso de forma computable, se tiene el siguiente algoritmo que calcula los \textbf{símbolos accesibles desde otros a partir de reglas unitarias}:

Este algoritmo se aplica a todos y cada uno de los símbolos no terminales.

\begin{algoritmo}\label{algoritmo-simbolos-accesibles-reglas-unitarias}{\bf\em Símbolos no terminales accesibles mediante reglas unitarias}
\newcount\algocount
\begin{algorithm}
{\bf\em inicio}
\ $Viejo \leftarrow \emptyset$
\ $Nuevo \leftarrow \{A\}$
\ {\bf\em mientras} $(Nuevo \neq Viejo)$ {\bf\em hacer} 
\ \ $Viejo \leftarrow Nuevo$
\ \ $Nuevo \leftarrow Viejo \cup \{B | A \longrightarrow B \in P \wedge A \in Viejo\}$
\ {\bf\em fin mientras}
\ $N_A \leftarrow Nuevo$
{\bf\em fin}
\end{algorithm}
\end{algoritmo}

 
\begin{ejemplo}\label{ejemplo-conjuntos-unitarios}

 Considérese la gramática del ejemplo \ref{ejemplo-gramatica-expresiones-no-ambigua} que genera expresiones aritméticas. El cálculo del conjunto $N_E$ tiene los siguientes pasos:
\begin{description}
\item[\em Paso 0:] Inicialmente el conjunto $Viejo$ está vacío. El símbolo no terminales $E$ se incluye en $Nuevo$
\item[\em Paso 1:] Como los conjuntos $Viejo$ y $Nuevo$ son diferentes, se asigna a $Viejo$ el valor de $Nuevo$ y se añaden a $Nuevo$ el símbolo $T$ debido a la existencia de la producción unitaria $E \longrightarrow T$.
\item[\em Paso 2:] Como la condición de salida del bucle no se cumple, se asigna $Viejo$ el valor de $Nuevo$ y se incluye en $Nuevo$ el símbolo no terminal $F$ debido a la existencia de la producción unitaria $T \longrightarrow F$.
\item[\em Paso 3:] Puesto que la condición de salida todavía no se cumple, se asigna el valor de $Nuevo$ a $Viejo$.
\item[\em Paso final:] El bucle termina porque los conjuntos $Viejo$ y $Nuevo$ son iguales
\end{description}

\begin{figure}[htb]
\begin{center}
\begin{tabular}{||c|c|c||}
\hline 
    {\bf\em  Paso}  & {\bf\em Viejo}  & {\bf\em Nuevo}   \\
\hline 
\hline 
       0       &  $\emptyset$ & $\{E\}$  \\
\hline 
       1       &  $\{E\}$ & $\{E,T\}$ \\
\hline 
       2       &  $\{E,T\}$ & $\{E,T,F\}$ \\
\hline 
       3       &  $\{E,T,F\}$ & $\{E,T,F\}$  \\
\hline 
\end{tabular}
\end{center}
\caption{Pasos del algoritmo que calcula los símbolos no terminales que son accesibles mediante reglas unitarias a partir del símbolo $E$.}\label{fig-pasos-algoritmo-conjunto-unitarios}
\end{figure}

 Por tanto, $N_E = \{E,T,F\}$. Análogamente se pueden calcular los conjuntos $N_S = \{S\}, N_T = \{T,F\}$ y $N_F = \{F\}$.
\end{ejemplo}

\begin{algoritmo}\label{algoritmo-eliminar-reglas-unitarias}{\bf\em Eliminación de reglas unitarias}
\begin{itemize}
\item Entrada: $G = (V_N,V_T,P,S)$ gramática de contexto libre y los conjuntos $N_A \hspace{1ex} \forall A \in V_N$.
\item Salida: $G' = (V'_N,V_T,P',S)$ gramática sin reglas unitarias.
\end{itemize}
\newcount\algocount
\begin{algorithm}
{\bf\em inicio}
\ $P' \leftarrow \emptyset$
\ {\bf\em para} cada $A \in V_N$ {\bf\em hacer}
\ \ {\bf\em para} cada $B \in N_A$ {\bf\em hacer}
\ \ \ {\bf\em si} $B \longrightarrow \alpha \in P$ no es una regla unitaria
\ \ \ \ {\bf\em entonces}  $P' \leftarrow P' \cup \{A \longrightarrow \alpha\}$
\ \ \ {\bf\em fin si}
\ \ {\bf\em fin para}
\ {\bf\em fin para}
\ $V'_N \leftarrow \{A |A \in V_N \wedge \exists A \longrightarrow \alpha \in P'\}$
{\bf\em fin}
\end{algorithm}
\end{algoritmo}

\begin{ejemplo}\label{ejemplo-quitar-reglas-unitarias}
 Considérese la gramática con reglas unitarias del ejemplo \ref{ejemplo-gramatica-expresiones-no-ambigua}:
\begin{eqnarray*}
   P & = & \{ \\
     & (1) & S \longrightarrow \mbox{\bf\em identificador } = \hspace{1ex} E \\
     & (2) & E \longrightarrow E \hspace{1ex} + \hspace{1ex} T \\
     & (3) & E \longrightarrow T \\
     & (4) & T \longrightarrow T \hspace{1ex} * \hspace{1ex} F \\
     & (5) & T \longrightarrow F \\
     & (6) & F \longrightarrow ( \hspace{1ex} E \hspace{1ex} ) \\
     & (7) & F \longrightarrow \mbox{\bf\em identificador} \\
     & (8) & F \longrightarrow \mbox{\bf\em número} \\ 
     &   &\}
\end{eqnarray*}

 Para eliminar las reglas unitarias de esta gramática, se necesitan los conjuntos $N_S$, $N_E$, $N_T$ y $N_F$ calculados en el ejemplo \ref{ejemplo-conjuntos-unitarios}. Los pasos para generar la nueva gramática sin reglas unitarias son:
\begin{description}
\item[\em Paso 1:] Como el conjunto $N_S = \{S\}$, se añaden a $P'$ todas las producciones de $S$, ya que ninguna es una regla unitaria.
\begin{eqnarray*}
     S & \longrightarrow & \mbox{\bf\em identificador } = \hspace{1ex} E 
\end{eqnarray*}

\item[\em Paso 2:] Las alternativas de las producciones no unitarias de los símbolos no terminales del conjunto $N_E = \{E,T,F\}$ se convierten en alternativas de las producciones del símbolo $E$.
\begin{eqnarray*}
  E &\longrightarrow& E \hspace{1ex} + \hspace{1ex} T \\
  E &\longrightarrow& T \hspace{1ex} * \hspace{1ex} F \\
  E &\longrightarrow& ( \hspace{1ex} E \hspace{1ex} ) \\
  E &\longrightarrow& \mbox{\bf\em identificador} \\
  E &\longrightarrow& \mbox{\bf\em número} 
\end{eqnarray*}

\item[\em Paso 3:] Las alternativas de las producciones no unitarias de los símbolos no terminales del conjunto $N_T = \{T,F\}$ se convierten en alternativas de las producciones del símbolo $T$.
\begin{eqnarray*}
  T &\longrightarrow &T \hspace{1ex} * \hspace{1ex} F \\
  T &\longrightarrow &( \hspace{1ex} E \hspace{1ex} ) \\
  T &\longrightarrow &\mbox{\bf\em identificador} \\
  T &\longrightarrow &\mbox{\bf\em número} 
\end{eqnarray*}

\item[\em Paso 4:] Como el conjunto $N_F = \{F\}$, se añaden a $P'$ todas las producciones de $F$, ya que ninguna es una regla unitaria.
\begin{eqnarray*}
     F &\longrightarrow& ( \hspace{1ex} E \hspace{1ex} ) \\
     F &\longrightarrow& \mbox{\bf\em identificador} \\
     F &\longrightarrow& \mbox{\bf\em número} 
\end{eqnarray*}
\end{description}

El nuevo conjunto de reglas de producción que se ha generado es:
\begin{eqnarray*}
  P' & = & \{ \\
     &  & S \longrightarrow \mbox{\bf\em identificador } = \hspace{1ex} E \\
     &  & E \longrightarrow E \hspace{1ex} + \hspace{1ex} T \hspace{1ex} | \hspace{1ex}  T \hspace{1ex} * \hspace{1ex} F \hspace{1ex} | \hspace{1ex} ( \hspace{1ex} E \hspace{1ex} ) \hspace{1ex} | \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} | \hspace{1ex}  \mbox{\bf\em número} \\ 
     &  & T \longrightarrow T \hspace{1ex} * \hspace{1ex} F \hspace{1ex} | \hspace{1ex} ( \hspace{1ex} E \hspace{1ex} ) \hspace{1ex} | \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} | \hspace{1ex}  \mbox{\bf\em número} \\
     &  & F \longrightarrow ( \hspace{1ex} E \hspace{1ex} ) \hspace{1ex} | \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} | \hspace{1ex} \mbox{\bf\em número} \\ 
     &  &\}
\end{eqnarray*}
\end{ejemplo}

Puede darse el caso en el que al eliminar las reglas unitarias surjan símbolos inútiles, como se puede observar en el siguiente ejemplo.
\begin{ejemplo}
 Considérese el conjunto de producciones $P'$ que se obtiene al eliminar las producciones $\epsilon$ de la gramática del ejemplo \ref{ejemplo-reglas-epsilon}. Los conjuntos de símbolos no terminales que son accesibles mediante producciones unitarias son:
\begin{eqnarray*}
 N_{S'} & =  & \{S',S,B,C,E\}\\
 N_S & = & \{S, B,C,E\} \\
 N_A & = & \{A,D\} \\
 N_B & = & \{S,B,C,E\} \\
 N_C & = & \{S,B,C,E\} \\
 N_D & = & \{A,D\} \\
 N_E & = & \{S,B,C,E\}  
\end{eqnarray*}

 La aplicación del algoritmo \ref{algoritmo-eliminar-reglas-unitarias} permite generar el siguiente conjunto de producciones: 
\begin{eqnarray*}
 P'  & = & \{ \\
 & &  S' \longrightarrow  \epsilon \hspace{1ex} | \hspace{1ex} A D \hspace{1ex} | \hspace{1ex} C E \hspace{1ex} | \hspace{1ex} a \hspace{1ex} | \hspace{1ex} c \\ 
 & &  S \longrightarrow \hspace{1ex} A D \hspace{1ex} | \hspace{1ex} C E \hspace{1ex} | \hspace{1ex} a \hspace{1ex} | \hspace{1ex} c \\ 
 & &  A \longrightarrow C D E \hspace{1ex} | \hspace{1ex} D E \hspace{1ex} | \hspace{1ex} C D \hspace{1ex} | \hspace{1ex} b \\ 
 & &  B \longrightarrow C  E  \hspace{1ex} | \hspace{1ex}  A D \hspace{1ex} | \hspace{1ex} a \hspace{1ex} | \hspace{1ex} c \\
 & &  C \longrightarrow A D  \hspace{1ex} | \hspace{1ex} C E \hspace{1ex} | \hspace{1ex} a \hspace{1ex} | \hspace{1ex} c \\
 & &  D \longrightarrow C D E  \hspace{1ex} | \hspace{1ex} D E \hspace{1ex} | \hspace{1ex} C D \hspace{1ex} | \hspace{1ex} b \\
 & &  E \longrightarrow A D  \hspace{1ex} | \hspace{1ex} C E \hspace{1ex} | \hspace{1ex} a \hspace{1ex} | \hspace{1ex} c \\
 & & \}
\end{eqnarray*}

 Como se puede observar, los símbolos $S$ y $B$ no son accesibles, porque no aparecen en la parte derecha de ninguna regla de producción. Por tanto, estos dos símbolos son inútiles y se pueden omitir.
\end{ejemplo}

\subsection{Recursividad por la izquierda}

\begin{definicion}
 Una {\bf\em gramática es recursiva} si posee derivaciones recursivas de la forma $A \Dflecha \alpha A \beta$ donde $\alpha, \beta \in V^* = (V_N \cup V_T)^*$
\end{definicion}

\begin{definicion}
 Una {\bf\em gramática es recursiva por la izquierda\footnote{La definición de recursividad por la derecha es similar.}} si posee derivaciones recursivas de la forma $A \Dflecha A \alpha$ donde $\alpha \in V^* = (V_N \cup V_T)^*$.
\end{definicion}

\begin{definicion}
 Se dice que una recursividad por la izquierda es {\bf\em inmediata} si existe una derivación recursiva de un único paso, es decir, si existe una regla de producción recursiva de la forma $A \longrightarrow A \alpha \in P$. 

 Si la derivación recursiva consta de dos o más pasos, entonces la recursividad se denomina {\bf\em general}. 
\end{definicion}

\begin{ejemplo}
 La gramática del ejemplo \ref{ejemplo-gramatica-expresiones-no-ambigua} es una gramática con recursividad inmediata porque posee las reglas recursivas $E \longrightarrow E \hspace{1ex} + \hspace{1ex} T \hspace{1ex}$ y  $\hspace{1ex}T \longrightarrow T \hspace{1ex} * \hspace{1ex} F \hspace{1ex}$.

En cambio, existe recursividad general en una gramática que contenga las reglas  $A \longrightarrow B \hspace{1ex} C \hspace{1ex} D\hspace{1ex} $ y $\hspace{1ex} B \longrightarrow A \hspace{1ex} a $ porque permite generar la siguiente derivación recursiva por la izquierda en dos pasos:
\begin{eqnarray*}
 A & \Dflecha & B \hspace{1ex} C \hspace{1ex} D \\
   & \Dflecha & A \hspace{1ex} a \hspace{1ex} C \hspace{1ex} D
\end{eqnarray*}
\end{ejemplo}

Las gramáticas recursivas son útiles porque permiten la especificación sin\-tác\-tica de muchos lenguajes que requieren el uso de estructuras recursivas. Considérense los lenguajes de programación, los cuales necesitan que muchas de sus sentencias puedan ser generadas mediante gramáticas recursivas. La gramática del ejemplo \ref{ejemplo-quitar-reglas-unitarias}, que permite generar las  expresiones aritméticas, es un ejemplo de gramática recursiva, pero hay muchos ejemplos más. A continuación se muestran algunos.  


\begin{ejemplo}\label{ejemplo-gramaticas-recursivas} Ejemplos de gramáticas recursivas por la izquierda:
\begin{itemize} 
\item Parte izquierda de una sentencia de asignación múltiple en el lenguaje C: dado el siguiente conjunto de producciones
\begin{eqnarray*}
 P  & = & \{ \\
    & (1)  &  S  \longrightarrow L E  \\
    & (2)  &  L  \longrightarrow L \hspace{1ex} \mbox{\bf\em identificador } = \\
    & (3) &  L  \longrightarrow \mbox{\bf\em identificador } = \\
    & (4) &  E  \longrightarrow E \hspace{1ex} + \hspace{1ex} T  \\
    &   & \cdots \\
    &   & \}
\end{eqnarray*}
se puede generar la siguiente derivación recursiva
\begin{eqnarray*}
 S & \Dflecha_1 & L E \\
   & \Dflecha_2 & L \hspace{1ex} \mbox{\bf\em identificador } = \hspace{1ex} E \\
   & \Dflecha_2 & L \hspace{1ex} \mbox{\bf\em identificador } =  \hspace{1ex} \mbox{\bf\em identificador } = \hspace{1ex} E \\
   & \Dflecha_3 & \mbox{\bf\em identificador } = \hspace{1ex} \mbox{\bf\em identificador } =  \hspace{1ex} \mbox{\bf\em identificador } = \hspace{1ex} E 
\end{eqnarray*}
\item Lista de parámetros de un procedimiento o función:
\begin{eqnarray*}
 P  & = & \{ \\
    &   &  S  \longrightarrow \mbox{\bf\em identificador } ( L ) \\
    &   &  L  \longrightarrow L, \mbox{\bf\em identificador } \\
    &   &  L  \longrightarrow \mbox{\bf\em identificador }  \\
    &   & \cdots \\
    &   & \}
\end{eqnarray*}
\item Componente de un {\em array} de varias dimensiones:
\begin{eqnarray*}
 P  & = & \{ \\
    &   &  S  \longrightarrow \mbox{\bf\em identificador } D \\
    &   &  D  \longrightarrow D [\mbox{\bf\em número} ] \\
    &   &  D  \longrightarrow [\mbox{\bf\em número} ] \\
    &   & \cdots \\
    &   & \}
\end{eqnarray*}
\end{itemize} 
\end{ejemplo} 

 La recursividad, por tanto, es muy útil para generar componentes de los lenguajes de programación. Sin embargo, los analizadores sintácticos descendentes no pueden ser aplicados a gramáticas que sean recursivas por la izquierda. Por este motivo, a continuación se explica cómo se puede transformar una gramática recursiva por izquierda en otra gramática equivalente que sea recursiva por la derecha. Afortunadamente, los analizadores sintácticos descendentes sí se pueden aplicar a gramáticas con recursividad por la derecha. 

 Al  transformar una gramática recursiva por la izquierda en otra recursiva por la derecha se ha de tener en cuenta si la recursividad es inmediata o general.

\subsubsection{Supresión de la recursividad inmediata por la izquierda}\label{subsec-recursividad-inmediata}

\begin{definicion}
 Una gramática posee recursividad inmediata por la izquierda si tiene alguna producción de la forma $A \longrightarrow A \alpha$ donde $\alpha \in V^* = (V_N \cup V_T)^*$.
\end{definicion}

\begin{algoritmo}\label{algoritmo-recursividad-inmediata}{\bf\em Eliminación de la recursividad inmediata por la izquierda}
\begin{itemize}
\item Entrada: $G = (V_N,V_T,P,S)$ gramática de contexto libre con reglas recursivas por la izquierda.
\item Salida: $G' = (V'_N,V_T,P',S)$ gramática sin reglas de producción recursivas por la izquierda.
\end{itemize}
\newcount\algocount
\begin{algorithm}
{\bf\em inicio}
\ $P' \leftarrow \emptyset$
\ {\bf\em para} cada $A \in V_N$ {\bf\em hacer}
\ \ {\bf\em si} $A$ no tiene producciones recursivas 
\ \ \ {\bf\em entonces} se añaden a $P'$ las producciones de $A$ 
\ \ {\bf\em si no}
\ \ \ {\bf\em si} $A \longrightarrow A \alpha_1 | A \alpha_2 | \cdots | A \alpha_p |\beta_1 | \beta_2 | \cdots | \beta_q \in P$ 
\ \ \ \ donde $\alpha_i \neq \epsilon$ $\forall i \in \{1,2,\dots,p\}$ 
\ \ \ \ y $\beta_j$ no empieza por $A$ $\forall j \in \{1,2,\dots,q\}$ 
\ \ \ \ {\bf\em entonces} 
\ \ \ \ \ se añaden a $P'$ las producciones
\ \ \ \ \ $A \longrightarrow \beta | \beta_j A'  \hspace{3ex} \forall i \in \{1,2,\dots,p\}$
\ \ \ \ \ $A' \longrightarrow \alpha_i | \alpha_i A' \hspace{3ex} \forall j \in \{1,2,\dots,q\}$ 
\ \ \ \ \ donde $A'$ es un nuevo símbolo no terminal
\ \ \ {\bf\em fin si}
\ \ {\bf\em fin si}
\ {\bf\em fin para}
{\bf\em fin}
\end{algorithm}
\end{algoritmo}

\begin{ejemplo}\label{ejemplo-recursividad-general}
 Considérese el conjunto de producciones de la  gramática obtenida al eliminar reglas unitarias en el ejemplo \ref{ejemplo-quitar-reglas-unitarias}:
\begin{eqnarray*}
  P & = & \{ \\
     &  & S \longrightarrow \mbox{\bf\em identificador } = \hspace{1ex} E \\
     &  & E \longrightarrow E \hspace{1ex} + \hspace{1ex} T \hspace{1ex} | \hspace{1ex} T \hspace{1ex} * \hspace{1ex} F \hspace{1ex} | \hspace{1ex} ( \hspace{1ex} E \hspace{1ex} ) \hspace{1ex} | \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} | \hspace{1ex} \mbox{\bf\em número} \\ 
     &  & T \longrightarrow T \hspace{1ex} * \hspace{1ex} F \hspace{1ex} | \hspace{1ex} ( \hspace{1ex} E \hspace{1ex} ) \hspace{1ex} | \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} | \hspace{1ex} \mbox{\bf\em número} \\ 
     &  & F \longrightarrow ( \hspace{1ex} E \hspace{1ex} ) \hspace{1ex}| \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex}| \hspace{1ex} \mbox{\bf\em número} \\ 
     &  &\}
\end{eqnarray*}


\begin{description}
\item[\em Paso 1:] La producción de $S$ no es recursiva por la izquierda y, por tanto, se añade a $P'$.
\item[\em Paso 2:] El símbolo $E$ tiene una regla recursiva por la izquierda y cuatro más que no lo son. Las nuevas reglas que se añaden a $P'$ son:
\begin{eqnarray*}
      E & \longrightarrow &  \hspace{1ex} T \hspace{1ex} * \hspace{1ex} F \hspace{1ex} | \hspace{1ex} \hspace{1ex} ( \hspace{1ex} E \hspace{1ex} ) \hspace{1ex} | \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} | \hspace{1ex} \mbox{\bf\em número} \hspace{1ex} | \\
        &                 &  \hspace{1ex} T \hspace{1ex} * \hspace{1ex} F \hspace{1ex} E' \hspace{1ex} | \hspace{1ex} \hspace{1ex} ( \hspace{1ex} E \hspace{1ex} ) \hspace{1ex} E' \hspace{1ex} | \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} E' \hspace{1ex} | \hspace{1ex} \mbox{\bf\em número} \hspace{1ex} E'  \\
      E'  & \longrightarrow &  \hspace{1ex}  + \hspace{1ex} T | \hspace{1ex}  + \hspace{1ex} T \hspace{1ex} E' 
\end{eqnarray*}
\item[\em Paso 3:] El símbolo $T$ tiene una regla recursiva por la izquierda y tres más que no lo son. Las nuevas reglas que se añaden a $P'$ son:
\begin{eqnarray*}
      T & \longrightarrow &  \hspace{1ex} ( \hspace{1ex} E \hspace{1ex} ) \hspace{1ex} | \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} | \hspace{1ex} \mbox{\bf\em número} \hspace{1ex} | \\ 
        &                 &  \hspace{1ex} ( \hspace{1ex} E \hspace{1ex} ) \hspace{1ex} T' \hspace{1ex} | \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} T' \hspace{1ex} | \hspace{1ex} \mbox{\bf\em número} \hspace{1ex} T' \\ 
      T'  & \longrightarrow &  \hspace{1ex}  * \hspace{1ex} F \hspace{1ex} | \hspace{1ex}  * \hspace{1ex} F \hspace{1ex} T' 
\end{eqnarray*}
\item[\em Paso 4:] El símbolo $F$ no posee reglas recursivass. Por tanto, todas ellas se añaden a $P'$
\end{description}

El conjunto de producciones resultante es:
\begin{eqnarray*}
  P' & = & \{ \\
   &  & S \longrightarrow \mbox{\bf\em identificador } = \hspace{1ex} E \\
   &  &    E  \longrightarrow   \hspace{1ex} T \hspace{1ex} * \hspace{1ex} F \hspace{1ex} | \hspace{1ex} \hspace{1ex} ( \hspace{1ex} E \hspace{1ex} ) \hspace{1ex} | \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} | \hspace{1ex} \mbox{\bf\em número} \hspace{1ex} | \\
   &    &  \hspace{8ex} T \hspace{1ex} * \hspace{1ex} F \hspace{1ex} E' \hspace{1ex} | \hspace{1ex} \hspace{1ex} ( \hspace{1ex} E \hspace{1ex} ) \hspace{1ex} E' \hspace{1ex} | \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} E' \hspace{1ex} | \hspace{1ex} \mbox{\bf\em número} \hspace{1ex} E'  \\
  &  &   E'   \longrightarrow   \hspace{1ex}  + \hspace{1ex} T | \hspace{1ex}  + \hspace{1ex} T \hspace{1ex} E'  \\
  & &   T  \longrightarrow  \hspace{1ex} ( \hspace{1ex} E \hspace{1ex} ) \hspace{1ex} | \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} | \hspace{1ex} \mbox{\bf\em número} \hspace{1ex} | \\ 
  &  &  \hspace{8ex} ( \hspace{1ex} E \hspace{1ex} ) \hspace{1ex} T' \hspace{1ex} | \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} T' \hspace{1ex} | \hspace{1ex} \mbox{\bf\em número} \hspace{1ex} T' \\ 
  & &   T'  \longrightarrow   \hspace{1ex}  * \hspace{1ex} F \hspace{1ex} | \hspace{1ex}  * \hspace{1ex} F \hspace{1ex} T'  \\
   &  & F \longrightarrow ( \hspace{1ex} E \hspace{1ex} ) \hspace{1ex}| \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex}| \hspace{1ex} \mbox{\bf\em número} \\ 
     &  &\}
\end{eqnarray*}

 Para comprobar que las dos gramáticas son equivalentes, considérense las siguientes derivaciones. La primera derivación se ha generado utilizando la gramática original con producciones recursivas por la izquierda:  
\begin{eqnarray*}
  S  & \Dflecha & \mbox{\bf\em identificador } = \hspace{1ex} E \\
     & \Dflecha & \mbox{\bf\em identificador } = \hspace{1ex} E \hspace{1ex} + \hspace{1ex} T \\
     & \Dflecha & \mbox{\bf\em identificador } = \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} + \hspace{1ex} T \\
     & \Dflecha & \mbox{\bf\em identificador } = \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} + \hspace{1ex} \mbox{\bf\em identificador}
\end{eqnarray*}
La segunda derivación genera la misma cadena que la anterior pero utiliza las producciones de la nuevas gramática sin recursividad por la izquierda:
\begin{eqnarray*}
  S  & \Dflecha & \mbox{\bf\em identificador } = \hspace{1ex} E \\
     & \Dflecha & \mbox{\bf\em identificador } = \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} E' \\
     & \Dflecha & \mbox{\bf\em identificador } = \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} + \hspace{1ex} T \\
     & \Dflecha & \mbox{\bf\em identificador } = \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} + \hspace{1ex} \mbox{\bf\em identificador} 
\end{eqnarray*}
\end{ejemplo}

\subsubsection{Supresión de la recursividad general por la izquierda}

\begin{algoritmo}\label{algoritmo-recursividad-general}{\bf\em Eliminación de la recursividad general por la izquierda}
\begin{itemize}
\item Entrada: $G = (V_N,V_T,P,S)$ gramática de contexto libre propia, es decir, sin ciclos, sin producciones $\epsilon$ ni símbolos inútiles.
\item Salida: $G' = (V'_N,V_T,P',S)$ gramática sin recursividad por la izquierda.
\end{itemize}
\newcount\algocount
\begin{algorithm}
{\bf\em inicio}
\ $P' \leftarrow \emptyset$
\ Ordénense los símbolos no terminales de la gramática: $\{A_1,A_2,\dots,A_n\}$
\ {\bf\em para} $i$ {\bf\em de} 1 {\bf\em a} $n$ {\bf\em hacer}
\ \ {\bf\em para} $j$ {\bf\em de} 1 {\bf\em a} $i-1$ {\bf\em hacer}
\ \ \ {\bf\em si} $A_i \longrightarrow A_j \hspace{1ex} \beta \hspace{1ex} \in P$
\ \ \ \ {\bf\em entonces} 
\ \ \ \ Añadir a $P'$ las producciones
\ \ \ \ \ $A_i \longrightarrow \alpha_1 \hspace{1ex} \beta \hspace{1ex} | \hspace{1ex} \cdots \hspace{1ex} | \hspace{1ex} \alpha_k \hspace{1ex} \beta$ 
\ \ \ \ donde 
\ \ \ \ \ $A_j \longrightarrow \alpha_1 \hspace{1ex} | \hspace{1ex} \cdots \hspace{1ex} | \hspace{1ex} \alpha_k$ 
\ \ \ \ son las producciones \underline{actuales} de $A_j$
\ \ \ {\bf\em fin si}
\ \ {\bf\em fin para}
\ \ Eliminar la recursividad inmediata por la izquierda 
\ \ de las producciones de $A_i$.
\ {\bf\em fin para}
{\bf\em fin}
\end{algorithm}
\end{algoritmo}

\begin{ejemplo}
 Considérese la siguiente gramática recursiva por la izquierda:
\begin{eqnarray*}
   P & = & \{ \\
     & (1) & S \longrightarrow A \hspace{1ex} B \\
     & (2) & S \longrightarrow c \\
     & (3) & A \longrightarrow B \hspace{1ex} b \\
     & (4) & A \longrightarrow S \hspace{1ex} d \\
     & (5) & A \longrightarrow a \\
     & (6) & B \longrightarrow S \hspace{1ex} b \\
     & (7) & B \longrightarrow A \hspace{1ex} a \\
     &   &\}
\end{eqnarray*}


\begin{description}
\item[\em Ordenamiento de los símbolos no terminales:] $\{S,A,B\}$
\item[\em Paso exterior 1:] Producciones de $S$
	\begin{description}
	\item[\em Paso interior 1:] $S$ no tiene ninguna producción que comience por un símbolo con un número de orden inferior al suyo.
	\item[\em Eliminación de la recusividad inmediata:] $S$ no tiene recursividad inmediata por la izquierda.
	\end{description}
\item[\em Paso exterior 2:] Producciones de $A$
	\begin{description}
	\item[\em Paso interior 1:] Sustitución de las producciones de $A$ que comienzan por $S$: la regla número (4) $A \longrightarrow S \hspace{1ex} d$ se sustituye por las reglas 
$$A \longrightarrow A \hspace{1ex} B \hspace{1ex} d \hspace{1ex} | \hspace{1ex} c \hspace{1ex} d$$
 quedando las reglas de $A$ de la siguiente forma:
$$A \longrightarrow A \hspace{1ex} B \hspace{1ex} d \hspace{1ex} | \hspace{1ex} B \hspace{1ex} b \hspace{1ex} | \hspace{1ex} c \hspace{1ex} d \hspace{1ex} | \hspace{1ex} a$$
	\item[\em Eliminación de la recusividad inmediata:] se sustituyen las producciones de $A$ por las siguientes producciones:
	\begin{eqnarray*}
	A & \longrightarrow &   B \hspace{1ex} b \hspace{1ex} | \hspace{1ex} c \hspace{1ex} d \hspace{1ex} | \hspace{1ex} a \hspace{1ex} | \\
	  &                 &   B \hspace{1ex} b \hspace{1ex} A' \hspace{1ex} | \hspace{1ex} c \hspace{1ex} d \hspace{1ex} A' \hspace{1ex} | \hspace{1ex} a \hspace{1ex} A' \\
	A' & \longrightarrow &   B \hspace{1ex} d \hspace{1ex} | \hspace{1ex}  B \hspace{1ex} d \hspace{1ex} A'
	\end{eqnarray*}
	\end{description}
\item[\em Paso exterior 3:] Producciones de $B$
	\begin{description}
	\item[\em Paso interior 1:] Sustitución de las producciones de $B$ que comienzan por $S$: la regla número (6) $B \longrightarrow S \hspace{1ex} b$ se sustituye por las reglas 
$$B \longrightarrow A \hspace{1ex} B \hspace{1ex} b \hspace{1ex} | \hspace{1ex} c \hspace{1ex} b$$
 quedando las reglas de $B$ de la siguiente forma:
$$B \longrightarrow A \hspace{1ex} B \hspace{1ex} b \hspace{1ex} | \hspace{1ex} c \hspace{1ex} b \hspace{1ex} | \hspace{1ex} A \hspace{1ex} a \hspace{1ex}$$
	\item[\em Paso interior 2:] Sustitución de las producciones de $B$ que comienzan por $A$: las regla  $B \longrightarrow A \hspace{1ex} B \hspace{1ex} b$ se sustituye por las reglas 
	\begin{eqnarray*}
	 B & \longrightarrow &  B \hspace{1ex} b \hspace{1ex} B \hspace{1ex} b \hspace{1ex} | \hspace{1ex} c \hspace{1ex} d  \hspace{1ex} B \hspace{1ex} b \hspace{1ex} | \hspace{1ex} a  \hspace{1ex} B \hspace{1ex} b \hspace{1ex} | \\
	   &                 &  B \hspace{1ex} b \hspace{1ex} A' \hspace{1ex} B \hspace{1ex} b \hspace{1ex} | \hspace{1ex} c \hspace{1ex} d \hspace{1ex} A' \hspace{1ex} B \hspace{1ex} b \hspace{1ex} | \hspace{1ex} a \hspace{1ex} A' \hspace{1ex} B \hspace{1ex} b \hspace{1ex} 
	\end{eqnarray*}
	y la regla  $B \longrightarrow A \hspace{1ex} a$ se sustituye por las reglas 
	\begin{eqnarray*}
	 B & \longrightarrow &  B \hspace{1ex} b \hspace{1ex} a \hspace{1ex} | \hspace{1ex} c \hspace{1ex} d \hspace{1ex} a \hspace{1ex} | \hspace{1ex} a \hspace{1ex} a \hspace{1ex} | \\
	   &                 &  B \hspace{1ex} b \hspace{1ex} A' \hspace{1ex} a \hspace{1ex} | \hspace{1ex} c \hspace{1ex} d \hspace{1ex} A' \hspace{1ex} a \hspace{1ex} | \hspace{1ex} a \hspace{1ex} A' \hspace{1ex} a 
	\end{eqnarray*}
 quedando las reglas de $B$ de la siguiente forma:
	\begin{eqnarray*}
	 B & \longrightarrow &  B \hspace{1ex} b \hspace{1ex} B \hspace{1ex} b \hspace{1ex} | \hspace{1ex} B \hspace{1ex} b \hspace{1ex} A' \hspace{1ex} B \hspace{1ex} b \hspace{1ex} | \hspace{1ex}  B \hspace{1ex} b \hspace{1ex} a \hspace{1ex} | \hspace{1ex} B \hspace{1ex} b \hspace{1ex} A' \hspace{1ex} a \hspace{1ex}  | \\
	   &                 & \hspace{1ex} c \hspace{1ex} d  \hspace{1ex} B \hspace{1ex} b \hspace{1ex} | \hspace{1ex} a  \hspace{1ex} B \hspace{1ex} b \hspace{1ex} |  \hspace{1ex} c \hspace{1ex} d \hspace{1ex} A' \hspace{1ex} B \hspace{1ex} b \hspace{1ex} | \hspace{1ex} a \hspace{1ex} A' \hspace{1ex} B \hspace{1ex} b \hspace{1ex} | \\
       &       & \hspace{1ex} b \hspace{1ex} a \hspace{1ex} | \hspace{1ex} c \hspace{1ex} d \hspace{1ex} a \hspace{1ex} | \hspace{1ex} a \hspace{1ex} a \hspace{1ex} | \hspace{1ex} c \hspace{1ex} d \hspace{1ex} A' \hspace{1ex} a \hspace{1ex} | \hspace{1ex} a \hspace{1ex} A' \hspace{1ex} a \hspace{1ex} | \\ 
	  &                 & \hspace{1ex} c \hspace{1ex} b 
	\end{eqnarray*}
	\item[\em Eliminación de la recusividad inmediata:] se sustituyen las producciones de $B$ por las siguientes producciones:
	\begin{eqnarray*}
	  B & \longrightarrow & \hspace{1ex} c \hspace{1ex} d  \hspace{1ex} B \hspace{1ex} b \hspace{1ex} | \hspace{1ex} a  \hspace{1ex} B \hspace{1ex} b \hspace{1ex} |  \hspace{1ex} c \hspace{1ex} d \hspace{1ex} A' \hspace{1ex} B \hspace{1ex} b \hspace{1ex} | \hspace{1ex} a \hspace{1ex} A' \hspace{1ex} B \hspace{1ex} b \hspace{1ex} | \\
       &       & \hspace{1ex} b \hspace{1ex} a \hspace{1ex} | \hspace{1ex} c \hspace{1ex} d \hspace{1ex} a \hspace{1ex} | \hspace{1ex} a \hspace{1ex} a \hspace{1ex} | \hspace{1ex} c \hspace{1ex} d \hspace{1ex} A' \hspace{1ex} a \hspace{1ex} | \hspace{1ex} a \hspace{1ex} A' \hspace{1ex} a \hspace{1ex} | \\ 
	  &                 & \hspace{1ex} c \hspace{1ex} b \hspace{1ex} | \\
	   &             & \hspace{1ex} c \hspace{1ex} d  \hspace{1ex} B \hspace{1ex} b \hspace{1ex} B' \hspace{1ex} | \hspace{1ex} a  \hspace{1ex} B \hspace{1ex} b \hspace{1ex} B' \hspace{1ex} |  \hspace{1ex} c \hspace{1ex} d \hspace{1ex} A' \hspace{1ex} B \hspace{1ex} b \hspace{1ex} B' \hspace{1ex} | \hspace{1ex} a \hspace{1ex} A' \hspace{1ex} B \hspace{1ex} b \hspace{1ex} B' \hspace{1ex} | \\
       &       & \hspace{1ex} b \hspace{1ex} a \hspace{1ex} B' \hspace{1ex} | \hspace{1ex} c \hspace{1ex} d \hspace{1ex} a \hspace{1ex} B' \hspace{1ex} | \hspace{1ex} a \hspace{1ex} a \hspace{1ex} B' \hspace{1ex} | \hspace{1ex} c \hspace{1ex} d \hspace{1ex} A' \hspace{1ex} a \hspace{1ex} B' \hspace{1ex} | \hspace{1ex} a \hspace{1ex} A' \hspace{1ex} a \hspace{1ex} B' \hspace{1ex} | \\ 
	  & & \hspace{1ex} c \hspace{1ex} b \hspace{1ex} B' \\
	 B' & \longrightarrow &  b \hspace{1ex} B \hspace{1ex} b \hspace{1ex} | \hspace{1ex} b \hspace{1ex} A' \hspace{1ex} B \hspace{1ex} b \hspace{1ex} | \hspace{1ex} b \hspace{1ex} a \hspace{1ex} | \hspace{1ex} b \hspace{1ex} A' \hspace{1ex} a \hspace{1ex}  | \\
	  & &  b \hspace{1ex} B \hspace{1ex} b \hspace{1ex} B' \hspace{1ex} | \hspace{1ex} b \hspace{1ex} A' \hspace{1ex} B \hspace{1ex} b \hspace{1ex} B' \hspace{1ex} | \hspace{1ex} b \hspace{1ex} a \hspace{1ex} B' \hspace{1ex} | \hspace{1ex} b \hspace{1ex} A' \hspace{1ex} a \hspace{1ex}  B' \hspace{1ex} 
	\end{eqnarray*}
	\end{description}
\end{description}


\end{ejemplo}

\subsection{Factorización por la izquierda}

 La factorización por la izquierda es una transformación gramátical útil pra generar una gramática para el análisis sintáctico descendente predictivo. La factorización permite retrasar la decisión de qué regla utilizar en función de la cadena de entrada que se esté analizando. Por ejemplo, considérense las siguientes producciones:
\begin{eqnarray*}
  S  & \longrightarrow & \mbox{\bf\em si} \hspace{1ex} E \hspace{1ex} \mbox{\bf\em entonces} \hspace{1ex} S \hspace{1ex} \mbox{\bf\em si no} \hspace{1ex} S \hspace{1ex} \mbox{\bf\em fin si} \hspace{1ex} | \\
     &                 & \mbox{\bf\em si} \hspace{1ex} E \hspace{1ex} \mbox{\bf\em entonces} \hspace{1ex} S \hspace{1ex} \mbox{\bf\em fin si} 
\end{eqnarray*}

Al leer el componente léxico {\bf\em si} no se sabe aún qué producción elegir para expandir la sentencia $S$.

 En general, si $A \longrightarrow \alpha \hspace{1ex} \beta_1 \hspace{1ex} | \hspace{1ex} \alpha \hspace{1ex} \beta_2$ son dos producciones de $A$ y la entrada a analizar comienza por una cadena no vacía derivada a partir de $\alpha$, no se sabe si expandir $A$ a $\alpha \hspace{1ex} \beta_1$ o a  $\alpha \hspace{1ex} \beta_2$. Para ello, las producciones se transforman en las siguientes producciones: 
\begin{eqnarray*}
  A  & \longrightarrow & \alpha \hspace{1ex} A' \\
  A'  & \longrightarrow & \beta_1 \hspace{1ex}| \hspace{1ex} \beta_2 
\end{eqnarray*}
  
\begin{algoritmo}\label{algoritmo-factorizacion}{\bf\em Factorización por la izquierda}
\begin{itemize}
\item Entrada: $G = (V_N,V_T,P,S)$ gramática de contexto libre propia.
\item Salida: $G' = (V'_N,V_T,P',S)$ gramática factorizada por la izquierda.
\end{itemize}
\newcount\algocount
\begin{algorithm}
{\bf\em inicio}
\ {\bf\em para} cada símbolo no terminal $A$ {\bf\em hacer}
\ \ {\bf\em mientras} $A$ tenga dos producciones \underline{actuales} con el mismo prefijo
\ \ {\bf\em hacer}
\ \ \ {\bf\em si} $\alpha$ es el prefijo más largo de dos o más
\ \ \ \ alternativas de $A$ y $\alpha \neq \epsilon$
\ \ \ \ {\bf\em entonces} 
\ \ \ \ \ Sustituir todas las producciones
\ \ \ \ \ \ $A \longrightarrow \alpha \hspace{1ex} \beta_1 \hspace{1ex} | \hspace{1ex} \cdots \hspace{1ex} | \hspace{1ex} \alpha \hspace{1ex} \beta_p \hspace{1ex} | \hspace{1ex} \delta_1 \hspace{1ex} | \hspace{1ex} \cdots \hspace{1ex} | \hspace{1ex} \delta_q$ 
\ \ \ \ \ donde $\delta_i$ no empieza por $\alpha$ $\forall i \in \{1,2,\dots,q\}$
\ \ \ \ \ por las producciones
\ \ \ \ \ \ $A \longrightarrow \alpha \hspace{1ex} A' \hspace{1ex} | \hspace{1ex} \delta_1 \hspace{1ex} | \hspace{1ex} \cdots \hspace{1ex} | \hspace{1ex} \delta_q$ 
\ \ \ \ \ \ $A' \longrightarrow \beta_1 \hspace{1ex} | \hspace{1ex} \cdots \hspace{1ex} | \hspace{1ex} \beta_p \hspace{1ex}$ 
\ \ \ {\bf\em fin si}
\ \ {\bf\em fin mientras}
\ {\bf\em fin para}
{\bf\em fin}
\end{algorithm}
\end{algoritmo}


\begin{ejemplo}
Considérese el siguiente conjunto de producciones de una gramática de contexto libre:
\begin{eqnarray*}
P & = & \{ \\
   &  & S   \longrightarrow  A \hspace{1ex} B \hspace{1ex} c \hspace{1ex}  |  \hspace{1ex} A  \hspace{1ex} B \hspace{1ex} d  \hspace{1ex} e  \hspace{1ex} | \hspace{1ex} A  \hspace{1ex} B \hspace{1ex} d  \hspace{1ex} f  \hspace{1ex} | \hspace{1ex} A  \hspace{1ex} B \hspace{1ex} S \\ 
  &  & A  \longrightarrow   a \\
  &  & B  \longrightarrow  b  \\
  & &  \}
\end{eqnarray*}

\begin{description}
\item[\em Paso 1:] $\alpha_1 = A B d$ es el prefijo más largo de dos producciones de $S$. Por tanto, las reglas de $S$ se sustituyen por las siguientes:
\begin{eqnarray*}
   S  & \longrightarrow &  A \hspace{1ex} B \hspace{1ex} d \hspace{1ex} S' \hspace{1ex}  |  \hspace{1ex} A  \hspace{1ex} B \hspace{1ex} c  \hspace{1ex} | \hspace{1ex} A  \hspace{1ex} B \hspace{1ex} S   \\
   S'  & \longrightarrow &  e \hspace{1ex}  |  \hspace{1ex} f
\end{eqnarray*}
 La cadena $\alpha_2 = A B$ es ahora el prefijo más largo de tres producciones actuales de $S$. Por tanto, las reglas de $S$ se sustituyen por las siguientes:
\begin{eqnarray*}
   S  & \longrightarrow &  A \hspace{1ex} B \hspace{1ex} S'' \\
   S''  & \longrightarrow &  d \hspace{1ex}  S' \hspace{1ex}  |   \hspace{1ex} c  \hspace{1ex} |  \hspace{1ex} S  \\
   S'  & \longrightarrow &  e \hspace{1ex}  |  \hspace{1ex} f
\end{eqnarray*}
\item[\em Pasos 2 y 3:] Las producciones de $A$ y $B$ no requieren factorización.
\end{description}

\end{ejemplo}


 Al eliminar la recursividad inmediata\footnote{Véase la subsección \ref{subsec-recursividad-inmediata}.} se obtienen reglas que han de ser factorizadas por la izquierda. El siguiente algoritmo permite realizar estas dos operaciones simultáneamente.

\begin{algoritmo}\label{algoritmo-recursividad-inmediata-factorizacion}{\bf\em Eliminación de la recursividad inmediata por la izquierda y factorización por la izquierda}
\begin{itemize}
\item Entrada: $G = (V_N,V_T,P,S)$ gramática de contexto libre con reglas recursivas por la izquierda.
\item Salida: $G' = (V'_N,V_T,P',S)$ gramática sin reglas de producción recursivas por la izquierda y factorizada por la izquierda.
\end{itemize}
\newcount\algocount
\begin{algorithm}
{\bf\em inicio}
\ $P' \leftarrow \emptyset$
\ {\bf\em para} cada $A \in V_N$ {\bf\em hacer}
\ \ {\bf\em si} $A$ no tiene producciones recursivas 
\ \ \ {\bf\em entonces} se añaden a $P'$ las producciones de $A$ 
\ \ {\bf\em si no}
\ \ \ {\bf\em si} $A \longrightarrow A \alpha_1 | A \alpha_2 | \cdots | A \alpha_p |\beta_1 | \beta_2 | \cdots | \beta_q \in P$ 
\ \ \ \ donde $\alpha_i \neq \epsilon$ $\forall i \in \{1,2,\dots,p\}$ 
\ \ \ \ y $\beta_j$ no empieza por $A$ $\forall j \in \{1,2,\dots,q\}$ 
\ \ \ \ {\bf\em entonces} 
\ \ \ \ \ se añaden a $P'$ las producciones
\ \ \ \ \ $A \longrightarrow \beta_j A'  \hspace{3ex} \forall i \in \{1,2,\dots,p\}$
\ \ \ \ \ $A' \longrightarrow \alpha_i A' | \epsilon \hspace{3ex} \forall j \in \{1,2,\dots,q\}$ 
\ \ \ \ \ donde $A'$ es un nuevo símbolo no terminal
\ \ \ {\bf\em fin si}
\ \ {\bf\em fin si}
\ {\bf\em fin para}
{\bf\em fin}
\end{algorithm}
\end{algoritmo}

\begin{ejemplo}
 Si consideramos de nuevo la gramática de las expresiones sin reglas unitarias:
\begin{eqnarray*}
  P & = & \{ \\
     &  & S \longrightarrow \mbox{\bf\em identificador } = \hspace{1ex} E \\
     &  & E \longrightarrow E \hspace{1ex} + \hspace{1ex} T \hspace{1ex} | \hspace{1ex}  T \hspace{1ex} * \hspace{1ex} F \hspace{1ex} | \hspace{1ex} ( \hspace{1ex} E \hspace{1ex} ) \hspace{1ex} | \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} | \hspace{1ex}  \mbox{\bf\em número} \\ 
     &  & T \longrightarrow T \hspace{1ex} * \hspace{1ex} F \hspace{1ex} | \hspace{1ex} ( \hspace{1ex} E \hspace{1ex} ) \hspace{1ex} | \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} | \hspace{1ex}  \mbox{\bf\em número} \\
     &  & F \longrightarrow ( \hspace{1ex} E \hspace{1ex} ) \hspace{1ex} | \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} | \hspace{1ex} \mbox{\bf\em número} \\ 
     &  &\}
\end{eqnarray*}
 la aplicación del algoritmo \ref{algoritmo-recursividad-inmediata-factorizacion} genera la siguiente gramática:
\begin{eqnarray*}
  P' & = & \{ \\
   &  & S \longrightarrow \mbox{\bf\em identificador } = \hspace{1ex} E \\
   & &   E  \longrightarrow  T \hspace{1ex} * \hspace{1ex} F \hspace{1ex} E' \hspace{1ex} | \hspace{1ex} \hspace{1ex} ( \hspace{1ex} E \hspace{1ex} ) \hspace{1ex} E' \hspace{1ex} | \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} E' \hspace{1ex} | \hspace{1ex} \mbox{\bf\em número} \hspace{1ex} E'  \\
   & &  E'  \longrightarrow  \hspace{1ex}  + \hspace{1ex} T \hspace{1ex} E' \hspace{1ex} |\hspace{1ex} \epsilon \\
   & &   T  \longrightarrow   \hspace{1ex} ( \hspace{1ex} E \hspace{1ex} ) \hspace{1ex} T' \hspace{1ex} | \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex} T' \hspace{1ex} | \hspace{1ex} \mbox{\bf\em número} \hspace{1ex} T' \\ 
   & &   T'  \longrightarrow   \hspace{1ex}  * \hspace{1ex} F \hspace{1ex} T' \hspace{1ex} | \hspace{1ex}   \epsilon \\
   &  & F \longrightarrow ( \hspace{1ex} E \hspace{1ex} ) \hspace{1ex}| \hspace{1ex} \mbox{\bf\em identificador} \hspace{1ex}| \hspace{1ex} \mbox{\bf\em número} \\ 
     &  &\}
\end{eqnarray*}
\end{ejemplo}

\subsection{Formas normales de las gramáticas de contexto libre}

 Algunas veces es imprescindible que las reglas de producción de las gramáticas de contexto libre posean alguna forma especial que facilite su posterior procesamiento. Las dos formas normales más frecuentes son la forma normal de Chomsky y la forma normal de Greibach. 

 En las subsecciones siguientes se explican las características de estas formas normales, los procesos que permiten transformar una gramática de contexto libre en una gramática que esté en la forma normal de Chomsky o de Greibach y, además, se indicará cuándo se requiere que una gramática posea una de estas dos formas normales.

\subsubsection{Forma normal de Chomsky}\label{subsec-chomsky}

\begin{definicion}\label{definicion-gramatica-chomsky}
 Se dice que una gramática de contexto libre está en la {\bf\em forma normal de Chomsky (F.N.C.)} si sus reglas son de una de estas dos formas:
\begin{eqnarray*}
	A & \longrightarrow & B \hspace{1ex} C \\
	A & \longrightarrow & a 
\end{eqnarray*}
donde $A, B, C \in V_N$ y $a \in V_T$
\end{definicion}

 Las gramáticas en la forma normal de Chomsky permiten aplicar el algoritm de Cocke, Younger y Kasami que permite comprobar si una gramática de contexto libre genera o no una cadena.

Los árboles sintácticos correspondientes a derivaciones gramáticas que estén en la forma normal de Chomsky son binarios. Esta propiedad será utilizada para caracterizar a los lenguajes de contexto libre mediante su lema de bombeo.

\begin{ejemplo}
Sea una gramática en la forma normal de Chomsky con el siguiente conjunto de producciones:
\begin{eqnarray*}
 P & = & \{ \\
   & (1) & S \longrightarrow  A \hspace{1ex} B \\
   & (2) & A \longrightarrow  A \hspace{1ex} B \\
   & (3) & A \longrightarrow  a \\
   & (4) & B \longrightarrow  B \hspace{1ex} B \\
   & (5) & B \longrightarrow  b \\
 & & \}
\end{eqnarray*}

La figura \ref{fig-arbol-gramatica-chomsky} muestra el árbol binario correspondiente a la siguiente derivación:
\begin{eqnarray*}
  S & \Dflecha_1 & A \hspace{1ex} B \\
    & \Dflecha_2 & A \hspace{1ex} B \hspace{1ex} B \\
    & \Dflecha_3 & a \hspace{1ex} B \hspace{1ex} B \\
    & \Dflecha_4 & a \hspace{1ex} B \hspace{1ex} B \hspace{1ex} B \\
    & \Dflecha_5 & a \hspace{1ex} b \hspace{1ex} B \hspace{1ex} B \\
    & \Dflecha_5 & a \hspace{1ex} b \hspace{1ex} b \hspace{1ex} B \\
    & \Dflecha_6 & a \hspace{1ex} b \hspace{1ex} b \hspace{1ex} b
\end{eqnarray*}
\end{ejemplo}

\begin{figure}[htb]
\centerline{
\psfig{file=figuras/gramaticas-contexto-libre/arbol-gramatica-chomsky.pdf,width=5cm} 
}
\caption{Árbol binario correspondiente a una derivación de una gramática en la forma normal de Chomsky.}\label{fig-arbol-gramatica-chomsky}
\end{figure}

\begin{teorema}\label{teorema-chomsky}
 Dada una gramática de contexto libre propia\footnote{Véase la definición \ref{definicion-gramatica-propia}.} G, se puede construir otra en gramática G' que esté en la forma normal de Chomsky que verifique que $L(G') = L(G) - \{\epsilon\}$.
\end{teorema}

\raisebox{0.75ex}{\fbox{}}
{\bf Demostración}

Si $G = (V_N, V_T,P,S)$ es una gramática de contexto libre propia entonces se va a generar una gramática en la forma normal de Chomsky mediante la aplicación de los siguientes pasos:
\begin{enumerate}
\item Generación de una gramática $G_1 = (V_{N_1}, V_T,P_1,S)$ donde las reglas de $P_1$ son de la forma 
\begin{eqnarray*}
	A & \longrightarrow & B_1 \hspace{1ex} B_2 \hspace{1ex} \dots \hspace{1ex} B_k \hspace{3ex} \mbox{donde } k \geq 2 \\
	A & \longrightarrow & a 
\end{eqnarray*}
verificándose que $L(G) = L(G_1)$.
\item A partir de la gramática $G_1$ obtenida en el paso anterior, se genera otra gramática $G_2$ que estará en la forma normal de Chomsky y que será equivalente a $G$, es decir, $L(G) = L(G_2)$.
\end{enumerate}

\begin{description}
\item[\em Paso 1:] Sea  $A \longrightarrow X_1 \hspace{1ex} X_2 \hspace{1ex} \dots \hspace{1ex} X_k \in P$:
	\begin{enumerate}
	\item Si $k = 1$ entonces la regla es simplemente $A  \longrightarrow  X_1$, donde  $X_1 \in V_T$, porque la gramática no tiene reglas unitarias al ser una gramática propia. En este caso, la regla $A  \longrightarrow  X_1$ se añade a $P_1$.
	\item Si $k \geq 2$ entonces se añade a $P_1$ la regla $A  \longrightarrow  B_1 \hspace{1ex} B_2 \hspace{1ex} \dots \hspace{1ex} B_k$ donde
	\begin{itemize}
	\item $B_i = X_i$ si $X_i \in V_N$
	\item o $B_i$ es un nuevo símbolo no terminal si $X_i = a_i \in V_T$, en cuyo caso, también se añade a $P_1$ la regla $B_i \longrightarrow  X_i$.
	\end{itemize}
	\end{enumerate}
Se verifica que $L(G_1) = L(G) - \{\epsilon\}$.
\item[\em Paso 2:] Para generar las reglas de $P_2$ se han analizar las reglas de $P_1$:
	\begin{enumerate}
	\item Si la regla de $P_1$ es de la forma $A \longrightarrow a$ entonces se añade a $P_2$.
	\item Si  $A \longrightarrow B_1 \hspace{1ex} B_2 \hspace{1ex} \dots \hspace{1ex} B_k \in P_1$ entonces se pueden presentar dos casos:
		\begin{enumerate}
		\item Si $k = 2$ entonces la regla está en la forma normal de Chomsky y se añade a $P_2$.
		\item Si $k \geq 3$ entonces se añaden a $P_2$ el siguiente conjunto de reglas:
			\begin{eqnarray*}
			A & \longrightarrow & B_1 \hspace{1ex} C_1 \\
			C_1 & \longrightarrow & B_2 \hspace{1ex} C_2 \\
			    & \cdots & \\
			C_{k-1} & \longrightarrow & B_{k-2} \hspace{1ex} C_{k-2} \\
			C_{k-2} & \longrightarrow & B_{k-1} \hspace{1ex} B_k
\end{eqnarray*}
		\end{enumerate}
 Todas estas reglas están en la forma normal de Chomsky.
	\end{enumerate}
\end{description}

Se verifica que $L(G_2) = L(G_1) = L(G) - \{\epsilon\}$. $G_2$ es la gramática $G'$ del enunciado del teorema.

\hfill\rule{1.5ex}{1.5ex}

\begin{ejemplo}
  Sea el siguiente conjunto de producciones de una gramática de contexto libre propia 
\begin{eqnarray*}
 P & = & \{ \\
   &  & S \longrightarrow  a \hspace{1ex} A \hspace{1ex} B \\
   &  & A \longrightarrow  a \hspace{1ex} B\hspace{1ex} b \\
   &  & A \longrightarrow  a \\
   &  & B \longrightarrow  b\hspace{1ex} b \\
 & & \}
\end{eqnarray*}

\begin{description}
\item[\em Paso 1:] Se genera el siguiente conjunto de producciones:  
\begin{eqnarray*}
 P_1 & = & \{ \\
   &  & S \longrightarrow  B_1 \hspace{1ex} A \hspace{1ex} B \\
   &  & A \longrightarrow  B_1 \hspace{1ex} B \hspace{1ex} B_2 \\
   &  & A \longrightarrow   a \\
   &  & B \longrightarrow  B_2 \hspace{1ex} B_2 \\
   &  & B_1 \longrightarrow  a \\
   &  & B_2 \longrightarrow  b \\
 & & \}
\end{eqnarray*}
\item[\em Paso 2:] 
\begin{eqnarray*}
 P_2 & = & \{ \\
   &  & S \longrightarrow B_1 \hspace{1ex} C_1 \\
   &  & C_1 \longrightarrow A \hspace{1ex} B \\
   &  & A \longrightarrow B_1 \hspace{1ex} C_2 \\
   &  & C_2 \longrightarrow B \hspace{1ex} B_2 \hspace{1ex} \\
   &  & A \longrightarrow a \\
   &  & B \longrightarrow B_2 \hspace{1ex} B_2 \\
   &  & B_1 \longrightarrow a \\
   &  & B_2 \longrightarrow b \\
 & & \}
\end{eqnarray*}
\end{description}

\end{ejemplo}

\subsubsection{Forma normal de Greibach}

\begin{definicion}
 Se dice que una gramática de contexto libre está en la {\bf\em forma normal de Greibach (F.N.G.)} si sus reglas son de la forma:
\begin{eqnarray*}
	A & \longrightarrow & a \hspace{1ex} \alpha 
\end{eqnarray*}
donde $A \in V_N$, $a \in V_T$ y $\alpha \in V^*_N$
\end{definicion}
 
 Si una gramática está en la forma normal de Greibach entonces se puede construir con facilidad un autómata con pila equivalente.
 
 Toda gramática de contexto libre se puede transformar en otra gramática que esté en la forma normal de Greibach si previamente ha sido transformada en otra gramática que esté en la forma normal de Chomsky.


\begin{teorema} Dada una gramática $G$ que esté en la forma normal de Chomsky, se puede construir otra gramática G' que esté en la forma normal de Greibach que sea equivalente.
\end{teorema}

\raisebox{0.75ex}{\fbox{}}
{\bf Demostración}

Si $G = (V_N, V_T,P,S)$ es una gramática de contexto libre que está en la forma normal de Chomsky, se va a construir otra gramática que estará en la forma normal de Greibach mediante la aplicación de los siguientes pasos:

\begin{enumerate}
\item Aplicación del algoritmo \ref{algoritmo-recursividad-general} que elimina la recursividad general por la  izquierda.
\item Transformación de las reglas de los símbolos no terminales de la gramática original.
\item Transformación de las reglas de los símbolos no terminales obtenidos al eliminar la recursividad inmediata.
\end{enumerate}

\begin{description}
\item[\em Paso 1:] Aplicación del algoritmo \ref{algoritmo-recursividad-general} que elimina la recursividad general por la  izquierda.
  
 Las reglas de producción resultantes serán de la forma:
\begin{eqnarray*}
 A_i & \longrightarrow & A_j \delta \hspace{2ex} \forall j > i \wedge i,j \in \{i,2, \dots, n\}  \\
 A_i & \longrightarrow & a \delta \\
 A'_i & \longrightarrow & \delta 
\end{eqnarray*}
donde $A_i, A_j \in V_N$, $a \in V_T$, los símbolos $A'_i$ $(i \in \{1,2,\dots,m\})$ han sido generados al eliminar la recursividad inmediata por la izquierda y $\delta \in (V_N  \cup \{A'_1, A'_2, \dots, A'_n\})*$.  En particular, la reglas del símbolo $A_n$ serán de la forma $A_n \longrightarrow  a \hspace{1ex} \delta$ y ya estarán en la forma normal de Greibach.

\item[\em Paso 2:] Transformación de las reglas de los símbolos no terminales de la gramática original mediante la aplicación del siguiente algoritmo: 


\begin{algoritmo}\label{algoritmo-paso2-greibach}{\bf\em Transformación de las reglas de los símbolos no terminales de la gramática original}
\newcount\algocount
\begin{algorithm}
{\bf\em inicio}
\ {\bf\em para} $i$ {\bf\em de} $n-1$ {\bf\em a} $1$ {\bf\em hacer}
\ \ {\bf\em para} $j$ {\bf\em de} $i+1$ {\bf\em a} $n$ {\bf\em hacer}
\ \ \ {\bf\em para} cada producción \underline{actual} de $A_i$ de la forma $A_i \longrightarrow A_j \hspace{1ex} \delta$ 
\ \ \ {\bf\em hacer}
\ \ \ \ {\bf\em si} $A_j \longrightarrow a_1 \hspace{1ex} \alpha_1 \hspace{1ex} | \hspace{1ex} a_2 \hspace{1ex} \alpha_2 \hspace{1ex} | \hspace{1ex} \cdots  \hspace{1ex} | \hspace{1ex} a_p \hspace{1ex} \alpha_p \hspace{1ex}$
\ \ \ \ \ son las producciones \underline{actuales} de $A_j$
\ \ \ \ \ {\bf\em entonces} $A_i \longrightarrow a_1 \hspace{1ex} \alpha_1 \hspace{1ex} \delta \hspace{1ex} | \hspace{1ex} a_2 \hspace{1ex} \alpha_2 \hspace{1ex} \delta \hspace{1ex} | \hspace{1ex} \cdots  \hspace{1ex} | \hspace{1ex} a_p \hspace{1ex} \alpha_p \hspace{1ex} \delta $
\ \ \ \ \ \ pasan a ser producciones \underline{actuales} de $A_i$
\ \ \ \ {\bf\em fin si}
\ \ \ {\bf\em fin para}
\ \ {\bf\em fin para}
\ {\bf\em fin para}
{\bf\em fin}
\end{algorithm}
\end{algoritmo}

 Las reglas de producción resultantes serán de la forma:
\begin{eqnarray*}
 A_i & \longrightarrow & a \hspace{1ex} \delta \\
 A'_i & \longrightarrow & \delta 
\end{eqnarray*}
En particular, todas la reglas de los símbolos no terminales originales estarán en la forma normal de Greibach.

\item[\em Paso 3:] Aplicación del siguiente algoritmo para transformar las reglas de los símbolos no terminales obtenidos al eliminar la recursividad inmediata:

\begin{algoritmo}\label{algoritmo-paso3-greibach}{\bf\em Transformación de las reglas de los símbolos obtenidos al eliminar la recursividad inmediata}
\newcount\algocount
\begin{algorithm}
{\bf\em inicio}
\ {\bf\em para} $i$ {\bf\em de} $1$ {\bf\em a} $m$ {\bf\em hacer}
\ \ {\bf\em para} $j$ {\bf\em de} $1$ {\bf\em a} $n$ {\bf\em hacer}
\ \ \ {\bf\em para} cada producción \underline{actual} de $A'_i$ de la forma $A'_i \longrightarrow A_j \hspace{1ex} \delta$ 
\ \ \ {\bf\em hacer}
\ \ \ \ {\bf\em si} $A_j \longrightarrow a_1 \hspace{1ex} \alpha_1 \hspace{1ex} | \hspace{1ex} a_2 \hspace{1ex} \alpha_2 \hspace{1ex} | \hspace{1ex} \cdots  \hspace{1ex} | \hspace{1ex} a_p \hspace{1ex} \alpha_p \hspace{1ex}$
\ \ \ \ \ son las producciones \underline{actuales} de $A_j$
\ \ \ \ \ {\bf\em entonces} $A'_i \longrightarrow a_1 \hspace{1ex} \alpha_1 \hspace{1ex} \delta \hspace{1ex} | \hspace{1ex} a_2 \hspace{1ex} \alpha_2 \hspace{1ex} \delta \hspace{1ex} | \hspace{1ex} \cdots  \hspace{1ex} | \hspace{1ex} a_p \hspace{1ex} \alpha_p \hspace{1ex} \delta $
\ \ \ \ \ \ pasan a ser producciones \underline{actuales} de $A'_i$
\ \ \ \ {\bf\em fin si}
\ \ \ {\bf\em fin para}
\ \ {\bf\em fin para}
\ {\bf\em fin para}
{\bf\em fin}
\end{algorithm}
\end{algoritmo}

 Las reglas de producción resultantes serán de la forma:
\begin{eqnarray*}
 A_i & \longrightarrow & a \hspace{1ex} \delta \\
 A'_i & \longrightarrow & a \hspace{1ex} \delta 
\end{eqnarray*}
Por tanto, todas la reglas estarán en la forma normal de Greibach.
\end{description}
\hfill\rule{1.5ex}{1.5ex}

\begin{ejemplo}
Se va a obtener la gramática en la forma normal de Greibach equivalente a la siguiente gramática, que ya está en la forma normal de Chomsky:
\begin{eqnarray*}
   P & = & \{ \\
     & (1) & S \longrightarrow A \hspace{1ex} B \\
     & (2) & A \longrightarrow S \hspace{1ex} B  \\
     & (3) & A \longrightarrow a \\
     & (4) & B \longrightarrow B \hspace{1ex} A \\
     & (5) & B \longrightarrow d \\
     &    & \}
\end{eqnarray*}

\begin{description}
\item[Paso 1:] Aplicación del algoritmo de la recursividad general por la izquierda:
\begin{enumerate}
\item La regla de $S$ no necesita transformarse.
\item Se sustituye $S$ por su alternativa en la regla $ A \longrightarrow S \hspace{1ex} B$ generando la regla: 
     $$A \longrightarrow A \hspace{1ex} B \hspace{1ex} B$$
\item Eliminación de la recursividad por la izquierda de las reglas de $A$. Las reglas actuales de $A$ son
	\begin{eqnarray*}
         A & \longrightarrow & A \hspace{1ex} B \hspace{1ex} B \hspace{1ex} | \hspace{1ex} a 
	\end{eqnarray*}
 y las reglas que se generan al eliminar la recursividad inmendiata son:
	\begin{eqnarray*}
         A & \longrightarrow &  a \hspace{1ex} | \hspace{1ex} a \hspace{1ex} A'  \\
         A' & \longrightarrow & B \hspace{1ex} B \hspace{1ex} | B \hspace{1ex} B \hspace{1ex} A' 
	\end{eqnarray*}
\item No se tiene que sustituir ningún símbolo en las reglas de $B$.
\item Eliminación de la recursividad por la izquierda de las reglas de $B$. Las reglas actuales de $B$ son
	\begin{eqnarray*}
         B & \longrightarrow &  B \hspace{1ex} A \hspace{1ex} | \hspace{1ex} d
	\end{eqnarray*}
 y las reglas que se generan al eliminar la recursividad inmendiata son:
	\begin{eqnarray*}
         B & \longrightarrow &  d \hspace{1ex} | \hspace{1ex} d \hspace{1ex} B'  \\
         B' & \longrightarrow & A \hspace{1ex}|  \hspace{1ex} A \hspace{1ex} B' 
	\end{eqnarray*}
\end{enumerate}
\begin{eqnarray*}
   P_1 & = & \{ \\
     &  & S \longrightarrow A \hspace{1ex} B \\
     & & A \longrightarrow a \hspace{1ex} | \hspace{1ex} a \hspace{1ex} A'  \\
     & & B \longrightarrow d \hspace{1ex} | \hspace{1ex} d \hspace{1ex} B'  \\
     & & A' \longrightarrow B \hspace{1ex} B \hspace{1ex} | B \hspace{1ex} B \hspace{1ex} B' \\
     & & B' \longrightarrow  A \hspace{1ex}|  \hspace{1ex} A \hspace{1ex} B' \\
     & & \}
\end{eqnarray*}

\item[Paso 2:] Transformación de las reglas de los símbolos no terminales originales.
\begin{enumerate}
\item Las reglas de $B$ ya están en la forma normal de Greibach.
\item Las reglas de $A$ ya están en la forma normal de Greibach.
\item Se sustituye $A$ por sus alternativas en la regla $S \longrightarrow A \hspace{1ex} B$ generando las siguientes reglas de $S$:
	\begin{eqnarray*}
          S &  \longrightarrow & a \hspace{1ex} B \hspace{1ex} | \hspace{1ex} a \hspace{1ex} A' \hspace{1ex} B 
	\end{eqnarray*}
\end{enumerate}
\item[Paso 3:] Transformación de las reglas de los símbolos no terminales generados al eliminar la recursividad inmediata por la izquierda.
\begin{enumerate}
\item Trasformación de las reglas de $A'$:  $A' \longrightarrow B \hspace{1ex} B \hspace{1ex} | \hspace{1ex}  B \hspace{1ex} B \hspace{1ex} B' $. Se sustituye $B$ por sus alternativas, generándose las siguientes reglas de $A'$:
	\begin{eqnarray*}
         A' & \longrightarrow &  d \hspace{1ex} B \hspace{1ex} | \hspace{1ex} d \hspace{1ex} B \hspace{1ex} B' \hspace{1ex} | \hspace{1ex} d \hspace{1ex} B' \hspace{1ex}  B  \hspace{1ex} | \hspace{1ex} d \hspace{1ex} B' \hspace{1ex}  B \hspace{1ex} B'
	\end{eqnarray*}
\item Transformación de las reglas de $B'$: $B' \longrightarrow A \hspace{1ex} | \hspace{1ex} A \hspace{1ex} B'$. Se sustituye $A$ por sus alternativas, generándose las siguientes reglas de $B'$:
	\begin{eqnarray*}
         B' & \longrightarrow &  a \hspace{1ex} | \hspace{1ex} a \hspace{1ex} A' \hspace{1ex} | \hspace{1ex} a \hspace{1ex} B' \hspace{1ex}  | \hspace{1ex} a \hspace{1ex} A' \hspace{1ex} B'
	\end{eqnarray*}
\item Las reglas de $B'$ no requieren ninguna sustitución.
\end{enumerate}
\end{description}

El conjunto de producciones de la gramática en la forma normal de Greibach es:
\begin{eqnarray*}
   P_1 & = & \{ \\
       & & S  \longrightarrow a \hspace{1ex} B \hspace{1ex} | \hspace{1ex} a \hspace{1ex} A' \hspace{1ex} B  \\
     & & A \longrightarrow a \hspace{1ex} | \hspace{1ex} a \hspace{1ex} A'  \\
     & & B \longrightarrow d \hspace{1ex} | \hspace{1ex} d \hspace{1ex} B'  \\
     & & A' \longrightarrow   d \hspace{1ex} B \hspace{1ex} | \hspace{1ex} d \hspace{1ex} B \hspace{1ex} B' \hspace{1ex} | \hspace{1ex} d \hspace{1ex} B' \hspace{1ex}  B  \hspace{1ex} | \hspace{1ex} d \hspace{1ex} B' \hspace{1ex}  B \hspace{1ex} B' \\
     & & B' \longrightarrow  a \hspace{1ex} | \hspace{1ex} a \hspace{1ex} A' \hspace{1ex} | \hspace{1ex} a \hspace{1ex} B' \hspace{1ex}  | \hspace{1ex} a \hspace{1ex} A' \hspace{1ex} B' \\
     & & \}
\end{eqnarray*}
\end{ejemplo}
